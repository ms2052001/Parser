{"version":3,"sources":["webpack://MagicalParser/webpack/universalModuleDefinition","webpack://MagicalParser/webpack/bootstrap","webpack://MagicalParser/./build/index.js","webpack://MagicalParser/./src/errors.js","webpack://MagicalParser/./src/global.js","webpack://MagicalParser/./src/rules/Rule.js","webpack://MagicalParser/./src/Node.js","webpack://MagicalParser/./src/rules/Block.js","webpack://MagicalParser/./src/Grammer.js","webpack://MagicalParser/./src/Parser.js","webpack://MagicalParser/./src/tokens/Operators.js","webpack://MagicalParser/./src/OperatorsParser.js","webpack://MagicalParser/./src/tokens/Block.js","webpack://MagicalParser/./src/customParsers/index.js","webpack://MagicalParser/./src/customParsers/Math.js","webpack://MagicalParser/./src/customParsers/ProgMath.js","webpack://MagicalParser/./src/tokens/index.js","webpack://MagicalParser/./src/rules/AnyOf.js","webpack://MagicalParser/./src/rules/AnyThing.js","webpack://MagicalParser/./src/rules/Repeat.js","webpack://MagicalParser/./src/rules/Sequence.js","webpack://MagicalParser/./src/MagicalParser.js","webpack://MagicalParser/./src/tokens/TOKENS.js","webpack://MagicalParser/./src/rules/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","MagicalParser","require","forbiddenSymbolsError","msg","pos","position","messsege","Error","operatorsError","blocksError","regSpecialChars","str","replace","match","checker","symbols","isSymbol","test","isEmoji","isWhiteSpace","isNum","isNaN","isAlpha","spaced","isVarName","Math","g1","check","this","RegExp","console","log","sendError","type","undefined","Array","fill","join","Errors","contains","containedStr","indexOf","getRandomName","operationBlockChar","Date","now","randomNameNum","toString","specialChars","Rule","ruleDefualtName","childrenNum","childrenRules","properties","assign","length","rulesNum","rule","parentRule","groubIndex","groups","useValue","Block","blocks","children","child","concat","getBlocksInside","Node","args","attributes","props","prop","opening","source","closing","blockState","content","groupsNumInside","getGroupsNumInReg","reg","groupsNum","regStr","num","slice","openingReg","closingReg","ignoreBlockState","_blockStateToParents","id","increase","step","realRegex","getRegex","index","parser","Parser","rootParser","blocksRules","push","matchIdRegex","regex","parent","split","matches","parse","Grammer","_rule","prepareBlocks","prepareRegexes","grammer","matchesTest","setRootParser","prepareRegex","block","getMatches","_str","contentStart","startIndex","contentEnd","endIndex","shift","openingIndex","search","closingIndex","start","end","realIndexes","getMatchId","ii","arguments","pop","commonOperator","options","zIndex","regexStr","_name","_id","val","right","left","_spaced","Operator","SuffixOperator","PrefixOperator","Separator","OperatorsParser","prepareOptions","nameTest","numTest","operators","suffixOperators","prefixOperators","separators","forbiddenChars","all","processArr","arr","_all","op","repeated","opName","opIndex","parseInt","splice","allRegex","sort","a","b","values","openedBlock","rulesRegex","rules","forEach","nameTestReg","numTestReg","operationTestGrouped","operationTestGroupedReg","operationTest","operationTestReg","matchedTest","matchedTestReg","argTest","argTestReg","opTestReg","opIntialTestReg","opFinalTestReg","getMatchedString","operations","snode","Map","__clonedStr","__realPos","__parseBlocks","__parseOpertors","__parse","parseBlocks","parseOperators","subOptions","parseBLocks","sNode","pathTOme","funcName","funcArgs","_arg","sn","set","calls","func","extension","dotType","fullName","first","notNum","repBlock","childArg","tokenRef","__get","strs","str_","intialSearch","finalSearch","prevArg","prefix","arg","found","suffix","opened","global","flags","_contentTest","_options","autoMultSign","vars","__parseOperators","returnedValue","__parseArg","g2","arg1","arg2","parseFloat","find","v","ProgMath","AnyOf","AnyThing","Repeat","childRule","timesTOrepeat","repeatedRegex","Sequence","CustomParsers","TOKENS","STRING","NUMBER","BRACKETS","ROUND_BRACKETS","CURLEY_BRACKETS","SQUARE_BRACKETS","Tokens","Rules"],"mappings":"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","file":"MagicalParser.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MagicalParser\"] = factory();\n\telse\n\t\troot[\"MagicalParser\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\r\n// var Parser = require('../src/Parser').default;\r\n// var CustomParsers = require('../src/customParsers/index').default;\r\n\r\nvar MagicalParser = require('../src/MagicalParser.js').default;\r\n\r\nmodule.exports = MagicalParser;","export class forbiddenSymbolsError extends Error {\r\n   constructor(msg, pos) {\r\n      super(msg);\r\n      this.position = pos;\r\n      this.messsege = msg;\r\n   }\r\n}\r\n\r\nexport class operatorsError extends Error {\r\n   constructor(msg, pos) {\r\n      super(msg);\r\n      this.position = pos;\r\n      this.messsege = msg;\r\n   }\r\n}\r\n\r\nexport class blocksError extends Error {\r\n   constructor(msg, pos) {\r\n      super(msg);\r\n      this.position = pos;\r\n      this.messsege = msg;\r\n   }\r\n}\r\n\r\n","import * as Errors from \"./errors.js\";\r\n\r\nexport function regSpecialChars(str) {\r\n  return str.replace(/[+*/.$^(){|}[\\]]/g, match => {\r\n    return \"\\\\\" + match;\r\n  });\r\n}\r\n\r\nexport function strTOreg(str) {\r\n  return new RegExp(regSpecialChars(str));\r\n}\r\n\r\nexport function getGroupsNumInReg(reg) {\r\n  let groupsNum = 0;\r\n  /// reg .source == reg.toString().slice(1, ((reg) => { let num = reg.length - 1; while (reg[num] !== '/') num--; return num; })(reg.toString()))\r\n  let regStr = reg instanceof RegExp ? reg.source : reg;\r\n\r\n  if (regStr == \"\") return 0;\r\n\r\n  regStr = regStr\r\n    .replace(/\\\\./g, \"\")\r\n    // .replace(/\\\\\\(|\\\\\\)/, '')\r\n    .replace(/^([^(])+/, \"\");\r\n\r\n  if (regStr == \"\") return 0;\r\n\r\n  /// regStr[0] === '(' should be (\r\n\r\n  //#region get content of the group\r\n\r\n  //#endregion\r\n\r\n  if (regStr.indexOf(\"(\") > -1) {\r\n    let num = 1;\r\n    for (let i = 1; i < regStr.length; i++) {\r\n      if (regStr[i] == \")\") {\r\n        num--;\r\n      } else if (regStr[i] == \"(\") {\r\n        num++;\r\n      }\r\n      if (num == 0) {\r\n        // the group is closed\r\n        let content = regStr.slice(1, i);\r\n        if (regStr.slice(1, 3) !== \"?:\") groupsNum++;\r\n        groupsNum += getGroupsNumInReg(content);\r\n        regStr = regStr.slice(i + 1);\r\n        groupsNum += getGroupsNumInReg(regStr);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return groupsNum || 0;\r\n}\r\n\r\nexport var specialRegex = {\r\n  regSpecialChars: /[+*/.$^(){}[\\]]/,\r\n  num: /(-?\\d+\\.?\\d*)|(-?\\d*\\.?\\d+)/,\r\n  id: /[a-zA-Z_]+\\d*/\r\n  // var: // var is removed as you should care about other letters in other langs that I don't know how to check for using regex\r\n};\r\n\r\nexport var checker = {\r\n  symbols:\r\n    '!\"\\'#$%&()*+,-./:;<=>?@[\\\\]^_`{|}~€‚„…†‡ˆ‰‹‘’“”•–—˜™›¡¢£¤¥¦§¨©«¬®¯°±²³´¶·¸¹º»¼½¾¿×÷',\r\n\r\n  isSymbol: c =>\r\n    /(?:[$+<->^`|~\\xA2-\\xA6\\xA8\\xA9\\xAC\\xAE-\\xB1\\xB4\\xB8\\xD7\\xF7\\u02C2-\\u02C5\\u02D2-\\u02DF\\u02E5-\\u02EB\\u02ED\\u02EF-\\u02FF\\u0375\\u0384\\u0385\\u03F6\\u0482\\u058D-\\u058F\\u0606-\\u0608\\u060B\\u060E\\u060F\\u06DE\\u06E9\\u06FD\\u06FE\\u07F6\\u07FE\\u07FF\\u09F2\\u09F3\\u09FA\\u09FB\\u0AF1\\u0B70\\u0BF3-\\u0BFA\\u0C7F\\u0D4F\\u0D79\\u0E3F\\u0F01-\\u0F03\\u0F13\\u0F15-\\u0F17\\u0F1A-\\u0F1F\\u0F34\\u0F36\\u0F38\\u0FBE-\\u0FC5\\u0FC7-\\u0FCC\\u0FCE\\u0FCF\\u0FD5-\\u0FD8\\u109E\\u109F\\u1390-\\u1399\\u166D\\u17DB\\u1940\\u19DE-\\u19FF\\u1B61-\\u1B6A\\u1B74-\\u1B7C\\u1FBD\\u1FBF-\\u1FC1\\u1FCD-\\u1FCF\\u1FDD-\\u1FDF\\u1FED-\\u1FEF\\u1FFD\\u1FFE\\u2044\\u2052\\u207A-\\u207C\\u208A-\\u208C\\u20A0-\\u20BF\\u2100\\u2101\\u2103-\\u2106\\u2108\\u2109\\u2114\\u2116-\\u2118\\u211E-\\u2123\\u2125\\u2127\\u2129\\u212E\\u213A\\u213B\\u2140-\\u2144\\u214A-\\u214D\\u214F\\u218A\\u218B\\u2190-\\u2307\\u230C-\\u2328\\u232B-\\u2426\\u2440-\\u244A\\u249C-\\u24E9\\u2500-\\u2767\\u2794-\\u27C4\\u27C7-\\u27E5\\u27F0-\\u2982\\u2999-\\u29D7\\u29DC-\\u29FB\\u29FE-\\u2B73\\u2B76-\\u2B95\\u2B98-\\u2BFF\\u2CE5-\\u2CEA\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3004\\u3012\\u3013\\u3020\\u3036\\u3037\\u303E\\u303F\\u309B\\u309C\\u3190\\u3191\\u3196-\\u319F\\u31C0-\\u31E3\\u3200-\\u321E\\u322A-\\u3247\\u3250\\u3260-\\u327F\\u328A-\\u32B0\\u32C0-\\u33FF\\u4DC0-\\u4DFF\\uA490-\\uA4C6\\uA700-\\uA716\\uA720\\uA721\\uA789\\uA78A\\uA828-\\uA82B\\uA836-\\uA839\\uAA77-\\uAA79\\uAB5B\\uFB29\\uFBB2-\\uFBC1\\uFDFC\\uFDFD\\uFE62\\uFE64-\\uFE66\\uFE69\\uFF04\\uFF0B\\uFF1C-\\uFF1E\\uFF3E\\uFF40\\uFF5C\\uFF5E\\uFFE0-\\uFFE6\\uFFE8-\\uFFEE\\uFFFC\\uFFFD]|\\uD800[\\uDD37-\\uDD3F\\uDD79-\\uDD89\\uDD8C-\\uDD8E\\uDD90-\\uDD9B\\uDDA0\\uDDD0-\\uDDFC]|\\uD802[\\uDC77\\uDC78\\uDEC8]|\\uD805\\uDF3F|\\uD807[\\uDFD5-\\uDFF1]|\\uD81A[\\uDF3C-\\uDF3F\\uDF45]|\\uD82F\\uDC9C|\\uD834[\\uDC00-\\uDCF5\\uDD00-\\uDD26\\uDD29-\\uDD64\\uDD6A-\\uDD6C\\uDD83\\uDD84\\uDD8C-\\uDDA9\\uDDAE-\\uDDE8\\uDE00-\\uDE41\\uDE45\\uDF00-\\uDF56]|\\uD835[\\uDEC1\\uDEDB\\uDEFB\\uDF15\\uDF35\\uDF4F\\uDF6F\\uDF89\\uDFA9\\uDFC3]|\\uD836[\\uDC00-\\uDDFF\\uDE37-\\uDE3A\\uDE6D-\\uDE74\\uDE76-\\uDE83\\uDE85\\uDE86]|\\uD838[\\uDD4F\\uDEFF]|\\uD83B[\\uDCAC\\uDCB0\\uDD2E\\uDEF0\\uDEF1]|\\uD83C[\\uDC00-\\uDC2B\\uDC30-\\uDC93\\uDCA0-\\uDCAE\\uDCB1-\\uDCBF\\uDCC1-\\uDCCF\\uDCD1-\\uDCF5\\uDD10-\\uDD6C\\uDD70-\\uDDAC\\uDDE6-\\uDE02\\uDE10-\\uDE3B\\uDE40-\\uDE48\\uDE50\\uDE51\\uDE60-\\uDE65\\uDF00-\\uDFFF]|\\uD83D[\\uDC00-\\uDED5\\uDEE0-\\uDEEC\\uDEF0-\\uDEFA\\uDF00-\\uDF73\\uDF80-\\uDFD8\\uDFE0-\\uDFEB]|\\uD83E[\\uDC00-\\uDC0B\\uDC10-\\uDC47\\uDC50-\\uDC59\\uDC60-\\uDC87\\uDC90-\\uDCAD\\uDD00-\\uDD0B\\uDD0D-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDE53\\uDE60-\\uDE6D\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])/.test(\r\n      c\r\n    ),\r\n\r\n  isEmoji: c =>\r\n    /(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5\\uDEEB\\uDEEC\\uDEF4-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])/.test(\r\n      c\r\n    ),\r\n\r\n  isWhiteSpace: c =>\r\n    /[\\t-\\r \\x85\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/.test(c),\r\n\r\n  isNum: c => !isNaN(c),\r\n\r\n  isAlpha: c => !isNaN(c) && !checker.isSymbol(c),\r\n\r\n  spaced: c => !checker.isSymbol(c),\r\n\r\n  isVarName: function(str) {\r\n    let isvarname = true;\r\n    str.replace(/^\\s*(.*)\\d*\\s*$/, (Math, g1) => {\r\n      for (let c of g1) {\r\n        isvarname = this.isAlpha(c) || c === \"_\";\r\n        if (!isvarname) continue;\r\n      }\r\n    });\r\n  },\r\n\r\n  check: function(str, test) {\r\n    switch (test) {\r\n      case \"name\":\r\n        return this.isVarName(str);\r\n      case \"num\":\r\n        return !isNaN(str);\r\n      case \"all\":\r\n        return true;\r\n      default:\r\n        if (test instanceof RegExp) {\r\n          return test.test(str);\r\n        } else {\r\n          console.log(`checking test \"${test}\" is not supported.`);\r\n          return true;\r\n        }\r\n    }\r\n  }\r\n};\r\n\r\nexport function sendError(type, msg, str = \"\", pos = undefined) {\r\n  // (new Array(pos)).fill('_')     is the same as     '_'.repeat(pos)\r\n  str = str || \"\";\r\n  str = str === \"\" ? \"\" : \"\\n\" + str + \"\\n\";\r\n  if (!isNaN(pos)) {\r\n    pos = new Array(pos).fill(\"_\").join(\"\") + \"^\";\r\n  } else if (pos) {\r\n    // here the text in parsing process is multi line.\r\n    pos = `position: ${pos}`;\r\n  } else {\r\n    // pos is a falsy value\r\n    pos = \"\";\r\n  }\r\n  msg = msg + str + pos;\r\n\r\n  switch (type) {\r\n    case \"forbiddenChars\":\r\n      throw new Errors.forbiddenSymbolsError(msg);\r\n    case \"operators\":\r\n      throw new Errors.operatorsError(msg);\r\n    case \"blocks\":\r\n      throw new Errors.blocksError(msg);\r\n    default:\r\n      throw new Error(msg);\r\n  }\r\n}\r\n\r\nexport function contains(str, containedStr) {\r\n  return str.indexOf(containedStr) > -1;\r\n}\r\n\r\nexport function getRandomName() {\r\n  let num = 0;\r\n  /// randomNameNum is here to avoid getting the same random name if the code is implemented so fast\r\n\r\n  return (\r\n    getRandomName.operationBlockChar +\r\n    (Date.now() + getRandomName.randomNameNum++).toString(36) +\r\n    getRandomName.operationBlockChar\r\n  );\r\n}\r\ngetRandomName.randomNameNum = 0;\r\ngetRandomName.operationBlockChar = \"¶\";\r\n\r\nexport var operationBlockChar = \"¶\";\r\n\r\nexport var specialChars = [operationBlockChar];\r\n","import Block from \"./Block.js\";\r\n\r\nexport default class Rule {\r\n\r\n\r\n   constructor(ruleDefualtName, childrenNum, childrenRules, properties = {}) {\r\n      properties.name = properties.name || ruleDefualtName;\r\n      // if (!properties.parser) throw new Error('Magical Parser Rule \"' + properties.name + '\" Must Contian Parser');\r\n      Object.assign(this, Object.assign(properties, this)); /// setting properities with no ovrriding\r\n      this.childrenNum = childrenNum;\r\n      if (childrenRules.length !== childrenNum && childrenNum > -1) throw Error('rules num in ' + (this.name + ' ' || '') + 'must be ' + this.rulesNum);\r\n      for (let rule of childrenRules) {\r\n         rule.parentRule = this;\r\n      }\r\n      this.childrenRules = childrenRules;\r\n      /**\r\n       * \r\n       * there is something called rootPaser, this value wil be set inside the constructor of Parser class.\r\n       * \r\n       * \r\n       * \r\n       */\r\n   }\r\n\r\n\r\n   getRegex(groubIndex) {\r\n      return '';\r\n   }\r\n\r\n   parse(groups, useValue) {\r\n      /**\r\n      * \"useValue\" is here to be used in the Repeat rule while parsing\r\n      */\r\n      throw new Error(\"You mustn't call this function directly from the abstract class Rule.\");\r\n   }\r\n\r\n   getBlocksInside() {\r\n      if (this instanceof Block) {\r\n         return [rule];\r\n      }\r\n      let blocks = [];\r\n      for (let child of this.children) {\r\n         blocks.concat(child.getBlocksInside());\r\n      }\r\n      return blocks;\r\n   }\r\n\r\n}","\r\n/**\r\n   sNode stands for structural node, used to represent the structure of the input text.,,,\r\n   you can use the result (which is tree node of sNode with particular properities to do incredible things),\r\n   it is used as a parse in mathpackage: {<https://github.com/ms2052001/mathpackage>}\r\n*/\r\n\r\nexport default class Node {\r\n\r\n   /**\r\n    * @param {string} type is a on of these\r\n    *  'id', 'func', 'num', 'bool_op', 'binray_op', 'bool', op = {'+', '-', '*', '/', '^', '=', ...}\r\n    * \r\n    * @param {*} args array of sNode\r\n    * @param {*} attributes object contains attributes names and values.\r\n    */\r\n   constructor(type, args = [], attributes = {}) {\r\n      Object.assign(this, attributes);\r\n      this.args = args instanceof Array ? args : [args];\r\n      this.type = type;\r\n      // if (type === 'op') {\r\n      //    let boolOps = ['and', 'or', 'xor', 'not', '&&', '||', '!'];\r\n      //    if (this.__contains(this.name, ...boolOps)) {\r\n      //       this.type = 'bool_op';\r\n      //    }\r\n      //    else if (this.name == ' ==') {\r\n      //       this.type = 'assign_op';\r\n      //    }\r\n      //    else {\r\n      //       this.type = type;\r\n      //    }\r\n      // } else {\r\n      //    this.type = type;\r\n      // }\r\n      // if (this.type === 'id') {\r\n      //    if (this.name === 'true' || this.name === 'false') {\r\n      //       this.type = 'bool';\r\n      //    }\r\n      // }\r\n   }\r\n\r\n   get isLiteral() {\r\n      return this.type === 'literal';\r\n   }\r\n\r\n   check(props, argsCount = this.args.length) {\r\n      for (let prop in props) {\r\n         if (this[prop] !== props[prop]) return false;\r\n      }\r\n      return true;\r\n      // return (this.type === type || (this.type === 'op' && this.name === type)) && this.args.length === argsCount && this.type === type_;\r\n   }\r\n\r\n   contains(check) {\r\n      if(this.check(check)){\r\n         return true;\r\n      }\r\n      if(this.args)\r\n         for (let i = 0; i < this.args.length; i++){\r\n            if (this.args[i].contains(check)) return true;\r\n         }\r\n      return false;\r\n   }\r\n\r\n}\r\n","import Rule from './Rule.js';\r\nimport Node from '../Node.js';\r\nimport { getGroupsNumInReg, getRandomName, regSpecialChars, operationBlockChar } from '../global.js';\r\nimport Parser from '../Parser.js';\r\n\r\nexport default class Block extends Rule {\r\n   \r\n   /**\r\n    * \r\n    * @param {Object} properties \r\n    * you should set \r\n    * opening as regex or string, closing as RegExp or string,\r\n    * [optional] content: Rule or regex or string,\r\n    * [optional] parser: to be used for parsing the content\r\n    */\r\n   constructor(properties) {\r\n      properties.opening = properties.opening instanceof RegExp ? properties.opening.source : regSpecialChars(properties.opening);\r\n      properties.closing = properties.closing instanceof RegExp ? properties.closing.source : regSpecialChars(properties.closing);\r\n\r\n      if (properties.opening && properties.closing) {\r\n         if (properties.opening !== properties.closing) {\r\n            /** this Block can't be represented by regex */\r\n            properties.blockState = true;\r\n         }\r\n         properties.content = properties.content || 'all';\r\n         properties.groupsNumInside = 0; /// if the content is regex, we should take care of the groups inside\r\n         if (!(properties.content instanceof Rule)) {\r\n            if (properties.content instanceof RegExp) {\r\n               // converting regex into string\r\n               properties.content = properties.content.source;\r\n            } else {\r\n               /// evaluating special values such as \"all\".\r\n               properties.content = (properties.content === 'all') ? '(?:.|\\\\s)*?' : regSpecialChars(properties.content);\r\n            }\r\n            properties.groupsNumInside += getGroupsNumInReg(properties.content);\r\n         }\r\n         // properties.test = `${properties.opening}${properties.content}${properties.closing}`;\r\n      } else {\r\n         throw new Error('Error on defining your block, you should define the opening and closing properties as the regex or the text');\r\n      }\r\n\r\n      super('Block', 0, [], properties);\r\n\r\n      this.openingReg = new RegExp(this.opening);\r\n      this.closingReg = new RegExp(this.closing);\r\n\r\n   }\r\n\r\n   getRegex(groubIndex, ignoreBlockState) {\r\n      if (this.blockState && !ignoreBlockState) {\r\n         this._blockStateToParents();\r\n         this.id = getRandomName();\r\n\r\n         groubIndex = groubIndex || {\r\n            num: 0,\r\n            increase: function (step = 1) {\r\n               this.num += step;\r\n               return this;\r\n            }\r\n         };\r\n         this.realRegex = new RegExp(this.getRegex(null, true));\r\n         this.index = groubIndex.num;\r\n\r\n         if (this.content instanceof Rule) {\r\n            this.parser = new Parser(this.childrenRules[0]);\r\n         }\r\n\r\n         // rootParser is an instance of \"Parser\" class, it is defined in the constructor of \"Parser\" class\r\n         this.rootParser.blocksRules.push(this);\r\n         this.rootParser.blockState = true;\r\n\r\n         this.matchIdRegex = new RegExp(`${this.id}${operationBlockChar}\\\\d+${operationBlockChar}`); // the representing string in the total string\r\n         return `(${this.matchIdRegex.source})`;\r\n      } else {\r\n         groubIndex = groubIndex || {\r\n            num: 0,\r\n            increase: function (step = 1) {\r\n               this.num += step;\r\n               return this;\r\n            }\r\n         };\r\n         this.index = groubIndex.num;\r\n         let content;\r\n         if (this.content instanceof Rule) {\r\n            content = this.content.getRegex(groubIndex.increase());\r\n         } else {\r\n            groubIndex.increase(this.groupsNumInside + 1);\r\n            content = '(' + this.content + ')';\r\n         }\r\n         let regex = `${this.opening}${content}${this.closing}`;\r\n\r\n         this.regex = regex;\r\n         return `(${regex})`;\r\n      }\r\n   }\r\n\r\n   _blockStateToParents() {\r\n      let parent = this.parentRule;\r\n      while (parent) {\r\n         parent.blockState = true;\r\n         parent = parent.parentRule;\r\n      }\r\n   }\r\n\r\n   getMatchId(index) {\r\n      return this.id + operationBlockChar + index + operationBlockChar;\r\n   }\r\n\r\n   parse(groups, useValue) {\r\n      if (this.blockState) {\r\n         let value = useValue || groups[this.index + 1];\r\n         let args = [];\r\n         let index = (value.split(operationBlockChar))[3];\r\n         value = this.rootParser.matches[this.id][index]; // is defined at the rootParser in the paring process\r\n\r\n         //#region getting args\r\n         if (this.parser) {\r\n            args = this.parser.parse(value.content);\r\n         }\r\n         //#endregion\r\n\r\n         return new Node(this.name, args, {\r\n            match: value.str,\r\n            content: value.content /// the current group in the array is in the index : this.index + 1\r\n         });\r\n      } else {\r\n         let value = useValue || groups[this.index + 1];\r\n         let args = [];\r\n\r\n         //#region getting args\r\n         if (this.content instanceof Rule) {\r\n            args = this.content.parse(groups);\r\n         } else if (this.parser) {\r\n            args = this.parser.parse(value);\r\n         }\r\n         //#endregion\r\n\r\n         return new Node(this.name, args, {\r\n            match: value,\r\n            content: groups[this.index + 2] /// the current group in the array is in the index : this.index + 1\r\n         });\r\n      }\r\n   }\r\n\r\n}","import Block from './rules/Block.js';\r\n\r\nexport default class Grammer {\r\n   constructor(rule) {\r\n      this.rule = rule;\r\n   }\r\n\r\n   get rule() {\r\n      return this._rule;\r\n   }\r\n\r\n   set rule(value) {\r\n      this._rule = value;\r\n      this.prepareBlocks();\r\n      this.prepareRegexes();\r\n   }\r\n\r\n   // addRule(rule) {\r\n   //    if (!this.rules) this.rules = []; // to avoid errors on push into an undefined variable.\r\n   //    this.rules.push(rule);\r\n   //    this.blocks.push(rule.getBlocksInside());\r\n   //    this.regex.push(rule.getRegex());\r\n   // }\r\n\r\n   prepareBlocks() {\r\n      this.blocks = this.rule.getBlocksInside();\r\n   }\r\n   prepareRegexes() {\r\n      this.regex = rule.getRegex();\r\n   }\r\n}","import { regSpecialChars, operationBlockChar } from '../src/global.js';\r\nimport Grammer from './Grammer.js';\r\nimport Rule from './rules/Rule.js';\r\nexport default class Parser {\r\n   constructor(grammer) {\r\n      this.grammer = grammer instanceof Grammer ? grammer : grammer instanceof Rule ? new Grammer(grammer) : grammer;\r\n      this.blockState = !grammer.blocks || grammer.blocks.length === 0; // on this.prepareRegex();, if any Block Rule can't be searched as regex, this will be true\r\n\r\n      this.matchesTest = new RegExp(`(${operationBlockChar}\\\\w+${operationBlockChar})${operationBlockChar}(\\\\d+)${operationBlockChar}`, 'g');\r\n      this.matches = [];\r\n\r\n      //#region seting the rootParser\r\n      let setRootParser = (rule) => {\r\n         rule.rootParser = this;\r\n         for (let child of rule.childrenRules) {\r\n            setRootParser(child);\r\n         }\r\n      };\r\n      setRootParser(this.grammer);\r\n      //#endregion\r\n\r\n      this.prepareRegex();\r\n   }\r\n\r\n   prepareRegex() {\r\n      this.regex = new RegExp('^\\\\s*' + this.grammer.getRegex() + '\\\\s*$');\r\n   }\r\n\r\n   parse(str) {\r\n      if (this.regex && str) {\r\n\r\n         //#region getting groups\r\n         let groups;\r\n         if (this.blockState) {\r\n            /**  \r\n             * this when a Block in this.grammer can't be searched as regex,\r\n             *  we will use Block.id for searchin them\r\n             */\r\n\r\n            //#region brackets\r\n            for (let block of this.blocksRules) {\r\n               let getMatches = function (_str, matches, shift = 0) {\r\n                  let openingIndex = _str.search(block.openingReg),\r\n                     closingIndex = _str.search(block.closingReg);\r\n                  let contentStart, startIndex, contentEnd, endIndex;\r\n                  let length; /// to know the opening or closing string length \r\n                  //#region getting the matched string\r\n                  if (openingIndex > -1 && closingIndex > -1 && closingIndex > openingIndex) {\r\n\r\n                     //#region evaluating indexes\r\n                     length = 0;\r\n                     _str.replace(block.openingReg, (match) => { length = match.length; });\r\n                     startIndex = openingIndex;\r\n                     contentStart = openingIndex + length;\r\n                     _str = _str.slice(contentStart); // the string after the opening string of the block\r\n                     let num = 1;\r\n                     /// searching for closing index\r\n                     while (num > 0) {\r\n                        openingIndex = _str.search(block.openingReg);\r\n                        closingIndex = _str.search(block.closingReg);\r\n                        if (closingIndex > -1) {\r\n                           if (openingIndex > closingIndex || openingIndex === -1) {\r\n                              // here you are closing\r\n                              num--;\r\n                           } else {\r\n                              // here you are opening new block of the same opening\r\n                              num++;\r\n                           }\r\n                        } else {\r\n                           throw new Error(`block seams not to be closed, correct it and try again.`);\r\n                        }\r\n                     }\r\n\r\n                     length = 0;\r\n                     _str.slice(closingIndex).replace(block.closingReg, (match) => { length = match.length; });\r\n                     contentEnd = contentStart + closingIndex /* the length of the content */;\r\n                     endIndex = contentEnd + length /* the length of the closing string of the block */;\r\n                     //#endregion\r\n\r\n                     //#region here we have our indexes, well done.\r\n                     //start is the startingIndex in the origin string, and so for end;\r\n                     matches.push({\r\n                        str: str.slice(startIndex + shift, endIndex + shift),\r\n                        content: str.slice(contentStart + shift, contentEnd + shift),\r\n                        start: startIndex + shift, end: endIndex + shift,\r\n                        contentStart: contentStart + shift, contentEnd: contentEnd + shift,\r\n                        realIndexes: {\r\n                           start: startIndex + shift, end: endIndex + shift,\r\n                           contentStart: contentStart + shift, contentEnd: contentEnd + shift\r\n                        }\r\n                     });\r\n                     //#endregion\r\n\r\n                     // if we are not at the end of the string,,, get match from the reset of the passed _str\r\n                     _str = _str.slice(closingIndex + length); // getting the rest of the string\r\n                     if (_str !== '') {\r\n                        /// myClosingIndex  !== str.length - 1\r\n                        getMatches(_str, matches, shift + endIndex);\r\n                     }\r\n\r\n                  }\r\n                  //#endregion\r\n               };\r\n               let matches = [];\r\n               getMatches(str, matches);\r\n               this.matches[block.id] = matches;\r\n               for (let i = 0; i < matches.length; i++) {\r\n                  // there is matched string in the \"str\"\r\n                  if (block.realRegex.test(matches[i].str)) {\r\n                     let id = block.getMatchId(i);\r\n                     str = str.slice(0, matches[i].start) + id + str.slice(matches[i].end);\r\n                     for (let ii = i + 1; ii < matches.length; ii++) {\r\n                        let shift = id.length - matches[i].str.length;\r\n                        matches[ii].start += shift;\r\n                        matches[ii].end += shift;\r\n                        matches[ii].contentStart += shift;\r\n                        matches[ii].contentEnd += shift;\r\n                     }\r\n                  }\r\n               }\r\n\r\n            }\r\n            //#endregion\r\n\r\n         } /* else {    \r\n            // this is an awesome state, when all blocks can be represented as regex...\r\n            // I wish all the code to be wrapped around by an awesome algorithms and special states\r\n         } */\r\n\r\n         str.replace(this.regex, function () {\r\n            groups = arguments;\r\n         });\r\n         if (!groups) throw new Error(\"your code doesn't match\");\r\n         // groups = [...groups]; \r\n         groups.pop(); groups.pop();\r\n         //#endregion\r\n\r\n         return this.grammer.parse(groups);\r\n      } else {\r\n         throw new Error('Ops, there was a problem in parsing process, perhaps your string is not valid for starting parsing, or your grammer is not precise');\r\n      }\r\n   }\r\n\r\n}","\r\nimport { regSpecialChars, checker } from '../global.js';\r\n\r\n\r\nexport class commonOperator {\r\n   /**\r\n    * \r\n    * @param {Object} options id as regex or string, zIndex for priority \r\n    */\r\n   constructor(options) {\r\n      options = options || {};\r\n      options = Object.assign({ zIndex: 0 }, options); // overriding default options by the passed options (options argument)\r\n      Object.assign(this, options);\r\n   }\r\n\r\n   get name() {\r\n      return this._name || this._id;\r\n   }\r\n   set name(name) {\r\n      this._name = name;\r\n   }\r\n\r\n   get id() {\r\n      return this._id;\r\n   }\r\n   set id(val) {\r\n\r\n      if (!val || val === '') throw new Error('operator id can not be void or empty');\r\n\r\n      this._id = val;\r\n\r\n      // preparing regex for parsing process\r\n      if (val instanceof RegExp) {\r\n         this.regexStr = val.toString().slice(1, -1); // replacing special chars         \r\n      } else {\r\n         this.regexStr = regSpecialChars(val.toString()); // replacing special chars         \r\n      }\r\n      this.regex = new RegExp(this.regexStr);\r\n\r\n      // spaced property\r\n\r\n      this.spaced = {\r\n         right: checker.spaced(val[val.toString().length - 1]),\r\n         left: checker.spaced(val[0])\r\n      };\r\n\r\n   }\r\n\r\n   get spaced() {\r\n      return this._spaced;\r\n   }\r\n   set spaced(val) {\r\n      this._spaced = typeof val === 'object' ? Object.assign({}, val) : { right: val, left: val };\r\n   }\r\n\r\n   toString() {\r\n      return this.regexStr;\r\n   }\r\n}\r\n\r\nexport class Operator extends commonOperator {\r\n   constructor(options) {\r\n      super(options);\r\n   }\r\n}\r\n\r\nexport class SuffixOperator extends commonOperator {\r\n   constructor(options) {\r\n      super(options);\r\n   }\r\n}\r\n\r\nexport class PrefixOperator extends commonOperator {\r\n   constructor(options) {\r\n      super(options);\r\n   }\r\n}\r\n\r\nexport class Separator extends commonOperator {\r\n   constructor(options) {\r\n      super(options);\r\n   }\r\n}\r\n\r\n","/**\r\n * here is the flow chart of the algorithms::: {<https://www.lucidchart.com/invitations/accept/1c02df38-de1b-48da-8942-652652d373ea>}\r\n * \r\n * options include:\r\n * functions:: if is is applied the expr \" 1 + rg(2)\" will be considered as \" 1 + rg*(2)\", thus rg is constants, here we sill consider the functions you insert in addtion to the common functions such as ['sin', 'cos', ...]\r\n *\r\n * operators search regex at regexr.com \"https://regexr.com/4tbfe\"\r\n\r\n */\r\n\r\n// import sNode from './sNode';\r\nimport Node from './Node.js';\r\nimport { checker, sendError, getRandomName, contains } from './global.js';\r\nimport { Operator, Separator, PrefixOperator, SuffixOperator } from './tokens/Operators.js';\r\n\r\nexport default class OperatorsParser {\r\n\r\n   constructor(options = {}) {\r\n      this.options = options;\r\n      this.prepareOptions(options);\r\n   }\r\n\r\n   prepareOptions(options) {\r\n      let defaultOptions = {\r\n         nameTest: '[_a-zA-Z]+\\\\d*',\r\n         numTest: '\\\\d*\\\\.?\\\\d+|\\\\d+\\\\.?\\\\d*',\r\n         blocks: [],\r\n         args: [],\r\n\r\n         operators: [],\r\n         suffixOperators: [],\r\n         prefixOperators: [],\r\n         separators: [],\r\n\r\n         forbiddenChars: []\r\n      };\r\n\r\n      options = Object.assign(defaultOptions, options);\r\n      options.forbiddenChars = [...options.forbiddenChars, ...specialChars];\r\n\r\n      //#region all\r\n\r\n      //#region string\r\n\r\n      let all = {\r\n         operators: \"\",\r\n         prefixOperators: \"\",\r\n         suffixOperators: \"\"\r\n      };\r\n\r\n      let processArr = arr => {\r\n         if (arr && arr.length > 0) {\r\n            let _all = \" \";\r\n            for (let i = 0; i < arr.length; i++) {\r\n               let op = arr[i];\r\n               let repeated = false;\r\n               _all.replace(\r\n                  new RegExp(`\\\\(@(${op.regexStr})#(\\\\d*)\\\\)`),\r\n                  (match, opName, opIndex) => {\r\n                     Object.assign(arr[i], arr[parseInt(opIndex)]); // merging the repeated operators\r\n                     arr.splice(parseInt(opIndex), 1); // removing the previous operator wiht the same name\r\n                     repeated = true;\r\n                     return ` (@${op.toString()},#${i}) `;\r\n                  }\r\n               );\r\n               if (!repeated) _all += `(@${op.regexStr}#${i})`;\r\n            }\r\n            return _all;\r\n         }\r\n      };\r\n\r\n      all.operators = processArr(options.operators);\r\n      all.prefixOperators = processArr(options.prefixOperators);\r\n      all.suffixOperators = processArr(options.suffixOperators);\r\n\r\n      options.all = all;\r\n\r\n      //#endregion\r\n\r\n      //#region regex\r\n\r\n      all = {\r\n         operators: \"\",\r\n         prefixOperators: \"\",\r\n         suffixOperators: \"\"\r\n      };\r\n\r\n      processArr = arr => {\r\n         if (arr.length == 0) return \"\";\r\n         if (arr && arr.length > 0) {\r\n            let _all = \"\";\r\n            for (let i = 0; i < arr.length; i++) {\r\n               let op = arr[i];\r\n               // let repeated = false; /// it is done in string\r\n               _all += `${op.regexStr}|`;\r\n            }\r\n            return _all.slice(0, -1);\r\n         }\r\n      };\r\n\r\n      all.operators = processArr(options.operators);\r\n      all.prefixOperators = processArr(options.prefixOperators);\r\n      all.suffixOperators = processArr(options.suffixOperators);\r\n\r\n      options.allRegex = all;\r\n\r\n      //#endregion\r\n\r\n      //#endregion\r\n\r\n      //#region final steps\r\n\r\n      // sort the array to be inversely according to zIndex property.\r\n      if (options.operators)\r\n         options.operators = options.operators.sort(function (a, b) {\r\n            return -(a.zIndex - b.zIndex); // the negative sign is for reverse the array;\r\n         });\r\n\r\n      options.blocks = {\r\n         values: options.blocks,\r\n         openedBlock: null\r\n      };\r\n\r\n      //#endregion\r\n\r\n      //#region regex for search\r\n\r\n      options.rulesRegex = [];\r\n\r\n      options.rules.forEach(rule => {\r\n         options.rulesRegex.push(new RegExp(rule.getRegex()));\r\n      });\r\n\r\n      options.nameTestReg = new RegExp(options.nameTest);\r\n      options.numTestReg = new RegExp(options.numTest);\r\n\r\n      options.operationTestGrouped = `(?:(${options.nameTest})\\\\s*)?(` + operationBlockChar + options.nameTest + operationBlockChar + ')';\r\n      options.operationTestGroupedReg = new RegExp(`^\\\\s*${options.operationTestGrouped}\\\\s*$`);\r\n\r\n      options.operationTest = `(?:${options.nameTest}\\\\s*)?` + operationBlockChar + options.nameTest + operationBlockChar;\r\n      options.operationTestReg = new RegExp(`^\\\\s*${options.operationTest}\\\\s*$`);\r\n\r\n      options.matchedTest = operationBlockChar + options.nameTest + operationBlockChar;\r\n      options.matchedTestReg = new RegExp(options.matchedTest, 'g');\r\n\r\n      options.argTest = `${options.nameTest}(?:\\\\s*${operationBlockChar + options.nameTest + operationBlockChar})?|${options.numTest}|${options.operationTest}`;\r\n      options.argTestReg = new RegExp(`^\\\\s*(${options.argTest})\\\\s*$`);\r\n\r\n      options.opTestReg = new RegExp(\r\n         `^\\\\s*(${options.allRegex.suffixOperators})?\\\\s*(${options.allRegex.operators})\\\\s*(${options.allRegex.prefixOperators})?\\\\s*(${options.argTest})\\\\s*`\r\n      );\r\n      options.opIntialTestReg = new RegExp(\r\n         `^\\\\s*(${options.allRegex.prefixOperators})?\\\\s*(${options.argTest})`\r\n      );\r\n      options.opFinalTestReg = new RegExp(\r\n         `^\\\\s*(${options.allRegex.suffixOperators})\\\\s*$`\r\n      );\r\n\r\n      options.getMatchedString = function (str, operations) {\r\n         return str.replace(options.matchedTestReg, (name) => {\r\n            return operations.get(name).match;\r\n         });\r\n      };\r\n\r\n      //#endregion\r\n\r\n      return options;\r\n   }\r\n\r\n   /**\r\n    * @param {string} str the string to be parsed \r\n    * @param {object} options if you want to override the aleardy existing options\r\n    * @param {array} operations \r\n    */\r\n   parse(str, operations = null) {\r\n\r\n      var options = this.options;\r\n      var forbiddenChars = options.forbiddenChars;\r\n      var snode;\r\n\r\n      operations = operations instanceof Map ? operations : new Map();\r\n      this.__clonedStr = str; this.__realPos = 0;\r\n\r\n      //#region pre codes\r\n\r\n      // checking errors\r\n      for (let i = 0; i < forbiddenChars.length; i++) {\r\n         if (contains(str, forbiddenChars[i])) sendError('forbidden char ' + forbiddenChars[i]);\r\n      }\r\n\r\n      // if empty of characters\r\n      str = str.replace(/^\\s*$/, () => {\r\n         snode = new Node('');\r\n      }); if (snode) return snode;\r\n\r\n      str = this.__parseBlocks(str, operations);\r\n\r\n      for (let i = 0; i < options.rulesRegex.length; i++) {\r\n         str = str.replace(options.rulesRegex[i], () => {\r\n            return\r\n         });\r\n      }\r\n\r\n      str = this.__parseOpertors(str, operations);\r\n\r\n      //#endregion\r\n\r\n      this.__parse(str, options, operations, { parseBlocks: false, parseOperators: false });\r\n\r\n   }\r\n\r\n   __parse(str, options, operations, subOptions = {}) {\r\n\r\n      subOptions = Object.assign({ parseBlocks: true, parseOperators: true }, subOptions); /// or use Object.assign\r\n      let snode;\r\n\r\n      if (subOptions.parseBLocks) {\r\n         str = this.__parseBlocks(str, operations);\r\n      }\r\n      if (subOptions.parseOperators) {\r\n         str = this.__parseBlocks(str, operations);\r\n      }\r\n\r\n      //#region final codes\r\n\r\n      // if empty of characters\r\n      str = str.replace(/^\\s*$/, () => {\r\n         snode = new Node('');\r\n      }); if (snode) return snode;\r\n\r\n\r\n      // if name of operation\r\n      str = str.replace(new RegExp(`^\\\\s*(##${options.nameTest}##)\\\\s*$`), (match, opName) => {\r\n         snode = operations.get(opName).sNode;\r\n      });\r\n      if (snode) return snode;\r\n\r\n      // something.abc.funcName(arg1, ...)\r\n      str = str.replace(new RegExp(`^\\\\s*(${options.nameTest}\\\\s*\\\\.\\\\s*)+(?:(${options.nameTest})\\\\s*(##${options.nameTest}##))\\\\s*$`), (match, pathTOme, funcName, funcArgs) => {\r\n         let args = operations.get(funcArgs);\r\n         if (options.all.prefixOperators.search(new RegExp(` \\\\(@(${name}),#(\\\\d*)\\\\) `)) > -1) {\r\n            let _arg = operations.get(args);\r\n            let sn = new Node('prefixOperator', _arg, { name });\r\n            operations.set(name, sn);\r\n         }\r\n         else if (args.sNode.calls('()')) {\r\n            let func;\r\n            let extension = this.parse(pathTOme, operations);\r\n            func = new Node('implementFunction', args.sNode.args, { name: funcName }); // args.sNode.args the args of the bracket  it may be one or more;\r\n            snode = new Node('.', [extension, func], { dotType: 'function', fullName: pathTOme + funcName });\r\n         }\r\n      });\r\n      if (snode) return snode;\r\n\r\n      //something.id\r\n      str = str.replace(/^\\s*(.*)\\.(\\$\\$[_a-zA-z]+\\d*\\$\\$)\\s*$/, (match, pathTOme, id) => {\r\n         if (match) {\r\n            snode = new Node('.', [this.parse(first, operations), new Node('id', [], {\r\n               name: id\r\n            })], {\r\n               dotType: 'id',\r\n               extension: match\r\n            });\r\n         }\r\n      });\r\n      if (snode) return snode;\r\n\r\n      // if literal, number or variable or bool {true or false}, ...\r\n\r\n      str = str.replace(/^\\s*(([_a-zA-z]+)\\d*)\\s*$/, (match, value, notNum) => {\r\n         if (match) {\r\n            snode = new Node(notNum ? 'id' : 'num', [], { value: value });\r\n         }\r\n      });\r\n      if (snode) return snode;\r\n\r\n      str = str.replace(/^(-?\\d+\\.?\\d*)|(-?\\d*\\.?\\d+)$/, (match, value, notNum) => {\r\n         if (match) {\r\n            snode = new Node(notNum ? 'id' : 'num', [], { value: value });\r\n         }\r\n      });\r\n      if (snode) return snode;\r\n\r\n      throw new Error('invalid script.\\n' + str); // this shouldn't happen in ordinary cases, but this line of code is here for avoiding any flaw out of measurements\r\n\r\n      //#endregion\r\n\r\n   }\r\n\r\n   __parseBlocks(str, options, operations) {\r\n\r\n      //#region brackets\r\n\r\n      var blocks = options.blocks;\r\n\r\n      let b;\r\n\r\n      let repBlock = (match, content) => {\r\n         let name = getRandomName();\r\n         let childArg = b.parser ? b.parser.parse(content) : this.__parse(content, options, operations);\r\n         let sn = new Node('block', childArg, { id: b.id, tokenRef: b });\r\n         operations.set(name, sn);\r\n         return name;\r\n      };\r\n\r\n      for (let i = 0; i < blocks.length; i++) {\r\n         b = blocks[i];\r\n         str = str.replace(b.regex, repBlock);\r\n      }\r\n\r\n      //#endregion\r\n\r\n      return str;\r\n   }\r\n\r\n   __parseOperators(str, options, operations) {\r\n      /// RegExp: (var or num or block)(suffix)(op)(prefix)(var or num or block)\r\n      /// ((?:[a-zA-Z_]+\\d*)|(?:-?\\d+\\.?\\d*)|(?:-?\\d*\\.?\\d+))\\s*((?:\\+\\+))?\\s*((?:\\+))\\s*((?:\\+\\+|\\+|\\-))?\\s*((?:[a-zA-Z_]+\\d*)|(?:\\d+\\.?\\d*)|(?:\\d*\\.?\\d+))\r\n\r\n      //#region separators\r\n      //if (!_contains(str, ...operators)) str = str.replace(/\\s/g, '');\r\n      for (let s of options.separators) {\r\n         if (new RegExp(s.regex).test(str)) {\r\n            let name = this.__get;\r\n            let args = [];\r\n            let strs = str.split(s);\r\n            for (let str_ of strs) {\r\n               args.push(this.parse(str_, operations));\r\n            }\r\n            operations.set(name, new Node('separator', args, { name: s, length: args.length }));\r\n         }\r\n      }\r\n      //#endregion\r\n\r\n      //#region preparing ofr parsing process\r\n      let argTest = `${options.nameTest}|${options.numTest}|##${options.nameTest}##`;\r\n      let search = new RegExp(`^\\\\s*(${options.allRegex.suffixOperators})?\\\\s*(${options.allRegex.operators})\\\\s*(${options.allRegex.prefixOperators})?\\\\s*(${argTest})\\\\s*`),\r\n         intialSearch = new RegExp(`^\\\\s*(${options.allRegex.prefixOperators})?\\\\s*(${argTest})`),\r\n         finalSearch = new RegExp(`^\\\\s*(${options.allRegex.suffixOperators})\\\\s*$`);\r\n\r\n      let _str = '',\r\n         prevArg = {\r\n            name: null,\r\n            sn: null\r\n         };\r\n      //#endregion\r\n\r\n      //#region searchong for operators and parsing process\r\n      /// intial replacement\r\n      str = str.replace(intialSearch, (match, prefix, arg) => {\r\n         if (prefix) {\r\n            let a = arg,\r\n               b = 'prefixOperator',\r\n               c = prefix;\r\n            if (!isNaN(a)) {\r\n               /// number\r\n               let name = getRandomName();\r\n               let sn = new Node(\r\n                  b,\r\n                  new Node('number', [], { value: parseInt(a) }),\r\n                  { name: c }\r\n               );\r\n               operations.set(name, sn);\r\n               prevArg = { name, sn };\r\n            } else {\r\n               let found = false;\r\n               a.replace(`##${options.nameTest}##`, () => {\r\n                  found = true;\r\n               });\r\n               if (found) {\r\n                  /// operations\r\n                  let sn = new Node(\r\n                     b,\r\n                     operations.get(a), /// you can get it from operations but let's store it into prevArg.sn to speed our code a litte bit.\r\n                     { name: c }\r\n                  );\r\n                  operations.set(a, sn);\r\n                  prevArg.sn = { name: a, sn };\r\n               } else {\r\n                  /// varName\r\n                  let name = getRandomName();\r\n                  let sn = new Node(\r\n                     b,\r\n                     new Node('variable', [], { name: a }),\r\n                     { name: c }\r\n                  );\r\n                  operations.set(name, sn);\r\n                  prevArg = { name, sn };\r\n               }\r\n            }\r\n\r\n         } else {\r\n            let found = false;\r\n            arg.replace(`##${options.nameTest}##`, () => {\r\n               found = true;\r\n            });\r\n            if (found) {\r\n               prevArg = { name: arg, sn: operations.get(arg) };\r\n            } else {\r\n               prevArg = { name: arg };\r\n            }\r\n         }\r\n\r\n         return '';\r\n      });\r\n      let a;\r\n      while (a !== str) {\r\n         a = str;\r\n         /// if replacement is not implemented, str will sstill the same and while loop will close\r\n         str = str.replace(search, (match, suffix, op, prefix, arg) => {\r\n\r\n            if (!op) {\r\n               sendError('operators', 'invalid operators', str, null);\r\n            }\r\n\r\n            if (suffix) {\r\n               for (let i = 0; i < options.suffixOperators.length; i++) {\r\n                  if (options.suffixOperators[i].regex.test(suffix)) {\r\n                     /// creating an operations with type of  prefix operator,,, its arg is the prev arg\r\n                     let a = prevArg.name,\r\n                        b = 'suffixOperator',\r\n                        c = suffix;\r\n                     if (!isNaN(a)) {\r\n                        /// number\r\n                        let name = getRandomName();\r\n                        let sn = new Node(\r\n                           b,\r\n                           new Node('number', [], { value: parseInt(a) }),\r\n                           { name: c }\r\n                        );\r\n                        operations.set(name, sn);\r\n                        prevArg = { name, sn };\r\n                     } else {\r\n                        let found = false;\r\n                        a.replace(`##${options.nameTest}##`, () => {\r\n                           found = true;\r\n                        });\r\n                        if (found) {\r\n                           /// operations\r\n                           let sn = new Node(\r\n                              b,\r\n                              prevArg.sn, /// you can get it from operations but let's store it into prevArg.sn to speed our code a litte bit.\r\n                              { name: c }\r\n                           );\r\n                           operations.set(a, sn);\r\n                           prevArg.sn = sn;\r\n                        } else {\r\n                           /// varName\r\n                           let name = getRandomName();\r\n                           let sn = new Node(\r\n                              b,\r\n                              new Node('variable', [], { name: a }),\r\n                              { name: c }\r\n                           );\r\n                           operations.set(name, sn);\r\n                           prevArg = { name, sn };\r\n                        }\r\n                     }\r\n                  }\r\n               }\r\n            }\r\n\r\n            _str += prevArg.name + ' ' + op + ' ';\r\n\r\n            if (prefix) {\r\n               let a = arg,\r\n                  b = 'prefixOperator',\r\n                  c = prefix;\r\n               if (!isNaN(a)) {\r\n                  /// number\r\n                  let name = getRandomName();\r\n                  let sn = new Node(\r\n                     b,\r\n                     new Node('number', [], { value: parseInt(a) }),\r\n                     { name: c }\r\n                  );\r\n                  operations.set(name, sn);\r\n                  prevArg = { name, sn };\r\n               } else {\r\n                  let found = false;\r\n                  a.replace(`##${options.nameTest}##`, () => {\r\n                     found = true;\r\n                  });\r\n                  if (found) {\r\n                     /// operations\r\n                     let sn = new Node(\r\n                        b,\r\n                        operations.get(a), /// you can get it from operations but let's store it into prevArg.sn to speed our code a litte bit.\r\n                        { name: c }\r\n                     );\r\n                     operations.set(a, sn);\r\n                     prevArg.sn = { name: a, sn };\r\n                  } else {\r\n                     /// varName\r\n                     let name = getRandomName();\r\n                     let sn = new Node(\r\n                        b,\r\n                        new Node('variable', [], { name: a }),\r\n                        { name: c }\r\n                     );\r\n                     operations.set(name, sn);\r\n                     prevArg = { name, sn };\r\n                  }\r\n               }\r\n            } else {\r\n               let found = false;\r\n               arg.replace(`##${options.nameTest}##`, () => {\r\n                  found = true;\r\n               });\r\n               if (found) {\r\n                  prevArg = { name: arg, sn: operations.get(arg) };\r\n               } else {\r\n                  prevArg = { name: arg };\r\n               }\r\n            }\r\n\r\n            return '';\r\n\r\n         });\r\n      }\r\n      // final search\r\n      if (str !== '') {\r\n         str = str.replace(finalSearch, (match, suffix) => {\r\n\r\n            let a = prevArg.name,\r\n               b = 'suffixOperator',\r\n               c = suffix;\r\n            if (!isNaN(a)) {\r\n               /// number\r\n               let name = getRandomName();\r\n               let sn = new Node(\r\n                  b,\r\n                  new Node('number', [], { value: parseInt(a) }),\r\n                  { name: c }\r\n               );\r\n               operations.set(name, sn);\r\n               prevArg = { name, sn };\r\n            } else {\r\n               let found = false;\r\n               a.replace(`##${options.nameTest}##`, () => {\r\n                  found = true;\r\n               });\r\n               if (found) {\r\n                  /// operations\r\n                  let sn = new Node(\r\n                     b,\r\n                     prevArg.sn, /// you can get it from operations but let's store it into prevArg.sn to speed our code a litte bit.\r\n                     { name: c }\r\n                  );\r\n                  operations.set(a, sn);\r\n                  prevArg.sn = { name: a, sn };\r\n               } else {\r\n                  /// varName\r\n                  let name = getRandomName();\r\n                  let sn = new Node(\r\n                     b,\r\n                     new Node('variable', [], { name: a }),\r\n                     { name: c }\r\n                  );\r\n                  operations.set(name, sn);\r\n                  prevArg = { name, sn };\r\n               }\r\n            }\r\n\r\n            _str += prevArg.name;\r\n\r\n            return '';\r\n\r\n         });\r\n         if (str !== '') sendError('operators', 'invalid suffix operator at the end', '', null);\r\n      }\r\n      //#endregion\r\n\r\n      return _str;\r\n   }\r\n\r\n   //#region deprecated\r\n\r\n   //// deprecated // deprecated // deprecated // deprecated // deprecated \r\n   //// deprecated // deprecated // deprecated // deprecated // deprecated \r\n   //// deprecated // deprecated // deprecated // deprecated // deprecated\r\n\r\n   // __parseBlocks(str, options, operations) {\r\n\r\n   //    //#region brackets\r\n   //    var that = this;\r\n   //    var blocks = options.blocks;\r\n\r\n   //    let __parseBlock__ = (index, str_) => {\r\n   //       //// checking error,,, this ill be done on handling bracket's content, so don't do for this. \r\n   //       let name = getRandomName();\r\n\r\n   //       // let str_ = str.slice(index.opening, index.closing); /// cut the text from the next sibiling of the opening char until the current closing index\r\n   //       let b = blocks.openedBlock.ref;\r\n   //       let searchingTxt = b.opening + str_ + b.closing;\r\n   //       str = str.replace(searchingTxt, name); // if the replacement is global or not, there will no be any problem unless the developer using this library set a block with the same features as the bolck of our operation name.\r\n\r\n   //       let childArg;\r\n   //       if (b.handleContent) {\r\n   //          childArg = that.parse(str_); /// here you are parsing new string with no operations yet. /// getting the sNode from the string inside this bracket block with the same procedures, there is no need to pass operations as argument\r\n   //       } else {\r\n   //          childArg = new Node('undefined', [], { content: str_ }); /// getting the sNode from the string inside this bracket block with the same procedures, there is no need to pass operations as argument\r\n   //       }\r\n   //       let sn = new Node('block', [childArg], { opening: b.opening, closing: b.closing, name: b.name });\r\n   //       operations.set(name, sn);\r\n\r\n   //       b.opened = false; blocks.openedBlock = null; // reset\r\n\r\n   //       return index.closing + (name.length - searchingTxt.length); /// new_i /// setting the index, as the string may shrink or be taller, it depends on the length of the name\r\n   //    };\r\n\r\n   //    let __parseBlocks__ = (i_intial = 0) => {\r\n   //       for (let i = i_intial; i < str.length; i++) {\r\n   //          if (this.__realPos || this.__realPos === 0) this.__realPos += 1; // dealing with the intial str be fore the parsing process\r\n   //          for (let b of blocks) {\r\n   //             /// if a block is opened, closing has the priority, unless, opening has the priority::: you can notice this in ***Mohammed***, if you check the opening char first the num will increase to 2, thus the block will not be closed,,, and an error will occur.\r\n   //             if (blocks.openedBlock) {\r\n   //                if (str.slice(i, i + b.closing.length) === b.closing) {\r\n   //                   if (b !== options.blocks.openedBlock.ref) {\r\n\r\n   //                      let iof = options.blocks.openedBlock.ref.opening.indexOf(b.opening);\r\n   //                      if (iof > -1) {\r\n   //                         // options.blocks.openedBlock.ref.opening  contains  b.closing::: for example *** contains **, you can use these blocks formatting typing, **Mohammed** will be bold.\r\n   //                         options.blocks.openedBlock.mayCloseAt = { ref: b, index: i, iof };\r\n   //                      } else {\r\n   //                         b.num--;\r\n   //                      }\r\n\r\n   //                   } else {\r\n   //                      b.num--;\r\n   //                   }\r\n   //                } else if (str.slice(i, i + b.opening.length) === b.opening) {\r\n   //                   b.num++;\r\n   //                   i += b.opening.length - 1; // -1 here as for loop will add 1 to i, I want to set the index just after the opening char \r\n   //                   this.__realPos += b.opening.length - 1;\r\n   //                }\r\n   //             } else {\r\n   //                if (str.slice(i, i + b.opening.length) === b.opening) {\r\n   //                   b.num++;\r\n   //                   i += b.opening.length - 1; // -1 here as for loop will add 1 to i, I want to set the index just after the opening char \r\n   //                   this.__realPos += b.opening.length - 1;\r\n   //                   // if (!blocks.openedBlock) { /// if not open, then open\r\n   //                   b.opened = true;\r\n   //                   blocks.openedBlock = { ref: b, index: i };\r\n   //                   // }\r\n   //                } else if (str.slice(i, i + b.closing.length) === b.closing) {\r\n   //                   b.num--;\r\n   //                }\r\n   //             }\r\n\r\n   //             /// when a bracket is close, but not opened. e.g. ::: \" 1+2-5) \"\r\n   //             if (b.num < 0) {\r\n   //                if (b.mustOpen) {\r\n   //                   sendError('closing a block not opened.');\r\n   //                } else {\r\n   //                   b.num = 0;\r\n   //                }\r\n   //             }\r\n\r\n   //             /// if true, the bracket's block is defined.\r\n   //             if (b.num === 0 && b.opened) { /// may other brackets' num be zero, as it does not exist or as it is closed but it closed inside the block that we are setting,,, e.g.::: \" 1+2({1,2,3}^-1) \"\r\n   //                let index = {\r\n   //                   opening: blocks.openedBlock.index + blocks.openedBlock.ref.opening.length,\r\n   //                   closing: i\r\n   //                };\r\n   //                let _str = str.slice(index.opening, index.closing);\r\n   //                if (checker.check(_str, b.content)) {\r\n   //                   i = __parseBlock__(index, _str); /// __parseBlock__ returns the new_i\r\n   //                } else {\r\n   //                   b.num++; // the considered closing found is not compatible, so continue shearching for another closing char\r\n   //                }\r\n   //             }\r\n   //          }\r\n   //       }\r\n   //    };\r\n   //    __parseBlocks__();\r\n   //    /// after finishing looping searching for brackets blocks, oooops, what is this?!!!, oh, the bracket is not closed. send an error\r\n   //    if (blocks.openedBlock) {\r\n   //       if (blocks.openedBlock.mayCloseAt) {\r\n   //          let index = {\r\n\r\n   //             opening:\r\n   //                blocks.openedBlock.index +\r\n   //                // blocks.openedBlock.mayCloseAt.ref.opening.length +    this will be added later\r\n   //                blocks.openedBlock.mayCloseAt.iof,\r\n\r\n   //             closing: blocks.openedBlock.mayCloseAt.index\r\n\r\n   //          };\r\n   //          /// the opening can be for another block e.g.::: (( and (,when we close with )) the blocks is ((content)), otherwise if we close with ) our block is (content) and the second \"(\" is the first char in the content \r\n   //          blocks.openedBlock.ref.opened = false;\r\n   //          blocks.openedBlock.ref.num = 0;\r\n   //          blocks.openedBlock = { ref: blocks.openedBlock.mayCloseAt.ref, index: index.opening };\r\n   //          index.opening += blocks.openedBlock.mayCloseAt.ref.opening.length;\r\n\r\n   //          let _str = str.slice(index.opening, index.closing);\r\n   //          this.__realPos = str.length - 1 - index.closing;\r\n   //          let new_i;\r\n   //          if (checker.check(_str, blocks.openedBlock.mayCloseAt.ref.content)) {\r\n   //             new_i = __parseBlock__(index, _str); /// __parseBlock__ returns the new_i\r\n   //             __parseBlocks__(new_i);\r\n   //          } else {\r\n   //             if (blocks.openedBlock.ref.mustClose) {\r\n   //                sendError('block is not closed.', this.__realPos);\r\n   //             }\r\n   //             // the considered closing found is not compatible as content failed at the test, so continue shearching for another closing char\r\n   //             // so start just after the opening of the openedBlock.ref,,, \r\n   //             // new_i = index.opening;\r\n   //             this.__realPos -= _str.length;\r\n   //             __parseBlocks__(index.opening);\r\n   //          }\r\n\r\n   //       } else {\r\n   //          if (blocks.openedBlock.ref.mustClose) {\r\n   //             sendError('block is not closed.', this.__realPos);\r\n   //          } else {\r\n   //             let new_i = blocks.openedBlock.index + blocks.openedBlock.ref.opening.length;\r\n   //             this.__realPos -= (str.length - 1) - new_i;\r\n   //             blocks.openedBlock.ref.opened = false;\r\n   //             blocks.openedBlock = null;\r\n   //             __parseBlocks__(new_i);\r\n   //          }\r\n   //       }\r\n   //    }\r\n\r\n   //    //#endregion\r\n\r\n   //    return str;\r\n\r\n   // }\r\n\r\n   //#endregion\r\n}","\r\n// for exmaple brackets and quotations\r\n//{ opening: '{', closing: '}', num: 0, opened: false }\r\nimport { regSpecialChars } from '../global.js';\r\n\r\nexport default class Block {\r\n\r\n   constructor(options = {}) {\r\n      options = Object.assign({ parser: 'inherit' }, options); // put parser = 'inherit' as default, otherwise the specified value\r\n      Object.assign(this, options);\r\n      if (!this.opening || !this.closing) throw new Error('you must set the opening and the closing of the block');\r\n      // these properties are deprecated and algorithms was enhanced :._.:\r\n      this.opened = false;\r\n      this.num = 0;\r\n   }\r\n\r\n   get id() {\r\n      return this._id;\r\n   }\r\n\r\n   set id(val) {\r\n      if (val instanceof RegExp) {\r\n         this._id = val;\r\n         this.regex = val;\r\n         this.regexStr = val.source;\r\n      } else if (val instanceof Object) {\r\n         this._id = val;\r\n         this.opening = this.id.opening;\r\n         this.closing = this.id.closing;\r\n         \r\n         if (val.opening && val.closing) {\r\n\r\n            val.content = val.content || 'all';\r\n            if (val.content instanceof RegExp) {\r\n               val.content = val.content.source;\r\n            } else if (val.content === 'all') {\r\n               val.content = '(?:.*?|\\\\s*)*?';\r\n            } else {\r\n               val.content = regSpecialChars(val.content);\r\n            }\r\n            this.regexStr = `${regSpecialChars(val.opening)}(${val.content})${regSpecialChars(val.closing)}`;\r\n            this.regex = new RegExp(this.regexStr);\r\n\r\n         }\r\n      } else {\r\n         this._id = val;\r\n         this.regex = new RegExp(regSpecialChars(val));\r\n         this.regexStr = this.regex.source;\r\n      }\r\n      // settingthe regex to be global\r\n      if (!this.regex.global) this.regex = new RegExp(this.regex.source, (this.regex.flags || '') + 'g');\r\n   }\r\n\r\n   get name() {\r\n      if (!this._name) return this.opening + this.closing;\r\n      else return this._name;\r\n   }\r\n   set name(name) {\r\n      this._name = name;\r\n   }\r\n\r\n   get content() {\r\n      return this._contentTest || 'all';\r\n   }\r\n   set content(val) {\r\n      this._contentTest = val;\r\n   }\r\n\r\n}","import Math from './Math.js';\r\nimport ProgMath from './ProgMath.js';\r\n\r\nexport default {\r\n  Math,\r\n  ProgMath\r\n};","import {\r\n  Operator,\r\n  Separator,\r\n  PrefixOperator,\r\n  SuffixOperator\r\n} from \"../tokens/Operators.js\";\r\nimport Block from \"../tokens/Block.js\";\r\nimport Node from \"../Node.js\";\r\nimport {\r\n  sendError,\r\n  contains,\r\n  getRandomName,\r\n  specialChars,\r\n  operationBlockChar\r\n} from \"../global.js\";\r\n\r\nexport default class CustomMathParser {\r\n\r\n  constructor(options) {\r\n    this._options = {\r\n      autoMultSign: true,\r\n      vars: [], /// to be used in this case ::: ' 1 + var(2-5)' which is the same as ' 1+ var*(2-5)'\r\n      nameTest: \"[a-zA-Z_]+\\\\d*\",\r\n      numTest: \"\\\\d+\\\\.?\\\\d*|\\\\d*\\\\.?\\\\d+\",\r\n\r\n      prefixOperators: [\r\n        new PrefixOperator({ id: \"+\" }),\r\n        new PrefixOperator({ id: \"-\" })\r\n      ],\r\n\r\n      suffixOperators: [\r\n        new SuffixOperator({ id: \"!\" }),\r\n        new SuffixOperator({ id: \"deg\" }),\r\n        new SuffixOperator({ id: \"rad\" })\r\n      ],\r\n\r\n      operators: [\r\n        new Operator({ id: \".\", zIndex: 11 }), // the first operator to process\r\n        new Operator({ id: \"^\", zIndex: 10 }), // the 2nd operator to process\r\n        new Operator({ id: \"**\", zIndex: 10 }), // the 2nd operator to process\r\n        new Operator({ id: \"*\", zIndex: 9 }),\r\n        new Operator({ id: \"/\", zIndex: 9 }),\r\n        new Operator({ id: \"mod\", zIndex: 9 }),\r\n        new Operator({ id: \"+\", zIndex: 7 }),\r\n        new Operator({ id: \"-\", zIndex: 7 }),\r\n        new Operator({ id: \">>\", zIndex: 6 }),\r\n        new Operator({ id: \"<<\", zIndex: 6 }),\r\n        new Operator({ id: \">=\", zIndex: 5 }),\r\n        new Operator({ id: \"<=\", zIndex: 5 }),\r\n        new Operator({ id: \"!=\", zIndex: 5 }),\r\n        new Operator({ id: \"<\", zIndex: 5 }),\r\n        new Operator({ id: \">\", zIndex: 5 }),\r\n        new Operator({ id: \"==\", zIndex: 5 }),\r\n        new Operator({ id: \"&\", zIndex: 4 }),\r\n        new Operator({ id: \"band\", zIndex: 4 }),\r\n        new Operator({ id: \"|\", zIndex: 4 }),\r\n        new Operator({ id: \"bor\", zIndex: 4 }),\r\n        new Operator({ id: \"bxor\", zIndex: 4 }),\r\n        new Operator({ id: \"constrain\", zIndex: 4 }),\r\n        new Operator({ id: \"in\", zIndex: 3 }),\r\n        new Operator({ id: \"out\", zIndex: 3 }),\r\n        new Operator({ id: \"xnor\", zIndex: 1 }),\r\n        new Operator({ id: \"xor\", zIndex: 1 }),\r\n        new Operator({ id: \"nand\", zIndex: 1 }),\r\n        new Operator({ id: \"nor\", zIndex: 1 }),\r\n        new Operator({ id: \"or\", zIndex: 1 }),\r\n        new Operator({ id: \"and\", zIndex: 1 }),\r\n        new Operator({ id: \"||\", zIndex: 1 }),\r\n        new Operator({ id: \"&&\", zIndex: 1 }),\r\n        new Operator({ id: \"=\", zIndex: 0 }) // the last operator to be applied\r\n      ],\r\n\r\n      separators: [new Separator({ id: \";\" }), new Separator({ id: \",\" })],\r\n\r\n      blocks: [\r\n        new Block({ id: /\\(([^(]*?)\\)/, opening: '(', closing: ')' }),\r\n        new Block({ id: /\\{([^{]*?)\\}/, opening: '{', closing: '}' }),\r\n        new Block({ id: /\\[([^[]*?)\\]/, opening: '[', closing: ']' }),\r\n        new Block({ id: /\"(.*?|\\\\\")*\"/, opening: '\"', closing: '\"' }), /// string: \"\"\r\n        new Block({ id: /'(.*?|\\\\')*'/, opening: \"'\", closing: \"'\" }) /// string: ''\r\n      ],\r\n\r\n      forbiddenChars: []\r\n    };\r\n    this.options = Object.assign(this._options, (options || {}));\r\n  }\r\n\r\n  //#region options\r\n\r\n  get options() {\r\n    return this._options;\r\n  }\r\n\r\n  set options(options) {\r\n    this._options = this.prepareOptions(options);\r\n  }\r\n\r\n  prepareOptions(options) {\r\n    let defaultOptions = {\r\n      nameTest: '[_a-zA-Z]+\\\\d*',\r\n      numTest: '\\\\d*\\\\.?\\\\d+|\\\\d+\\\\.?\\\\d*',\r\n\r\n      operators: [],\r\n      suffixOperators: [],\r\n      prefixOperators: [],\r\n      separators: [],\r\n\r\n      blocks: [],\r\n      rules: [],\r\n\r\n      forbiddenChars: []\r\n    };\r\n    \r\n    options = Object.assign(defaultOptions, options);\r\n    options.forbiddenChars = [...options.forbiddenChars, ...specialChars];\r\n\r\n    //#region all\r\n\r\n    //#region string\r\n\r\n    let all = {\r\n      operators: \"\",\r\n      prefixOperators: \"\",\r\n      suffixOperators: \"\"\r\n    };\r\n\r\n    let processArr = arr => {\r\n      if (arr && arr.length > 0) {\r\n        let _all = \" \";\r\n        for (let i = 0; i < arr.length; i++) {\r\n          let op = arr[i];\r\n          let repeated = false;\r\n          _all.replace(\r\n            new RegExp(`\\\\(@(${op.regexStr})#(\\\\d*)\\\\)`),\r\n            (match, opName, opIndex) => {\r\n              Object.assign(arr[i], arr[parseInt(opIndex)]); // merging the repeated operators\r\n              arr.splice(parseInt(opIndex), 1); // removing the previous operator wiht the same name\r\n              repeated = true;\r\n              return ` (@${op.toString()},#${i}) `;\r\n            }\r\n          );\r\n          if (!repeated) _all += `(@${op.regexStr}#${i})`;\r\n        }\r\n        return _all;\r\n      }\r\n    };\r\n\r\n    all.operators = processArr(options.operators);\r\n    all.prefixOperators = processArr(options.prefixOperators);\r\n    all.suffixOperators = processArr(options.suffixOperators);\r\n\r\n    options.all = all;\r\n\r\n    //#endregion\r\n\r\n    //#region regex\r\n\r\n    all = {\r\n      operators: \"\",\r\n      prefixOperators: \"\",\r\n      suffixOperators: \"\"\r\n    };\r\n\r\n    processArr = arr => {\r\n      if (arr.length == 0) return \"\";\r\n      if (arr && arr.length > 0) {\r\n        let _all = \"\";\r\n        for (let i = 0; i < arr.length; i++) {\r\n          let op = arr[i];\r\n          // let repeated = false; /// it is done in string\r\n          _all += `${op.regexStr}|`;\r\n        }\r\n        return _all.slice(0, -1);\r\n      }\r\n    };\r\n\r\n    all.operators = processArr(options.operators);\r\n    all.prefixOperators = processArr(options.prefixOperators);\r\n    all.suffixOperators = processArr(options.suffixOperators);\r\n\r\n    options.allRegex = all;\r\n\r\n    //#endregion\r\n\r\n    //#endregion\r\n\r\n    //#region final steps\r\n\r\n    // sort the array to be inversely according to zIndex property.\r\n    if (options.operators)\r\n      options.operators = options.operators.sort(function (a, b) {\r\n        return -(a.zIndex - b.zIndex); // the negative sign is for reverse the array;\r\n      });\r\n\r\n    options.blocks = {\r\n      values: options.blocks,\r\n      openedBlock: null\r\n    };\r\n\r\n    //#endregion\r\n\r\n    //#region regex for search\r\n\r\n    options.rulesRegex = [];\r\n\r\n    options.rules.forEach(rule => {\r\n      options.rulesRegex.push(new RegExp(rule.getRegex()));\r\n    });\r\n\r\n    options.nameTestReg = new RegExp(options.nameTest);\r\n    options.numTestReg = new RegExp(options.numTest);\r\n\r\n    options.matchedTest = operationBlockChar + '\\\\w+' + operationBlockChar;\r\n    options.matchedTestReg = new RegExp(options.matchedTest, 'g');\r\n\r\n    options.operationTestGrouped = `(?:(${options.nameTest})\\\\s*)?(` + options.matchedTest + ')';\r\n    options.operationTestGroupedReg = new RegExp(`^\\\\s*${options.operationTestGrouped}\\\\s*$`);\r\n\r\n    options.operationTest = `(?:${options.nameTest}\\\\s*)?` + options.matchedTest;\r\n    options.operationTestReg = new RegExp(`^\\\\s*${options.operationTest}\\\\s*$`);\r\n    \r\n    options.argTest = `${options.nameTest}(?:\\\\s*${options.matchedTest})?|${options.numTest}|${options.operationTest}`;\r\n    options.argTestReg = new RegExp(`^\\\\s*(${options.argTest})\\\\s*$`);\r\n\r\n    options.opTestReg = new RegExp(\r\n      `^\\\\s*(${options.allRegex.suffixOperators})?\\\\s*(${options.allRegex.operators})\\\\s*(${options.allRegex.prefixOperators})?\\\\s*(${options.argTest})\\\\s*`\r\n    );\r\n    options.opIntialTestReg = new RegExp(\r\n      `^\\\\s*(${options.allRegex.prefixOperators})?\\\\s*(${options.argTest})`\r\n    );\r\n    options.opFinalTestReg = new RegExp(\r\n      `^\\\\s*(${options.allRegex.suffixOperators})\\\\s*$`\r\n    );\r\n\r\n    options.getMatchedString = function (str, operations) {\r\n      return str.replace(options.matchedTestReg, (name) => {\r\n        return operations.get(name).match;\r\n      });\r\n    };\r\n\r\n    //#endregion\r\n\r\n    return options;\r\n  }\r\n\r\n  //#endregion\r\n\r\n  parse(str, operations = null) {\r\n    var options = this.options;\r\n    operations = operations instanceof Map ? operations : new Map();\r\n    //#region pre codes\r\n    for (let i = 0; i < options.forbiddenChars.length; i++) {\r\n      if (contains(str, options.forbiddenChars[i]))\r\n        sendError(\"forbiddenSymbol\", \"forbidden symbol.\");\r\n    }\r\n    // // if empty\r\n    // str = str.replace(/\\s+/g, () => {\r\n    //    return ' ';\r\n    // });\r\n\r\n    //#endregion\r\n    return this.__parse(str, options, operations);\r\n  }\r\n\r\n  __parse(str, options, operations, subOptions = {}) {\r\n    subOptions = Object.assign({ parseBlocks: true, parseOperators: true }, subOptions); /// or use Object.assign\r\n\r\n    // if empty of characters\r\n    let snode;\r\n    str = str.replace(/^\\s*$/, () => {\r\n      snode = new Node(\"\", [], {match: str});\r\n    });\r\n    if (snode) return snode;\r\n\r\n    if (subOptions.parseBlocks) {\r\n      str = this.__parseBlocks(str, options, operations);\r\n    }\r\n    if (subOptions.parseOperators) {\r\n      str = this.__parseOperators(str, options, operations);\r\n    }\r\n    let returnedValue = this.__parseArg(str, options, operations);\r\n    returnedValue.match = returnedValue.match || options.getMatchedString(str, operations);\r\n    return returnedValue;\r\n  }\r\n\r\n  /**\r\n   * this modified version of __parseBlocks is much better and faster,,, we have gotten rid of if statements and varaible and alot of code that are redundant\r\n   */\r\n  __parseBlocks(str, options, operations) {\r\n    //#region brackets\r\n    var blocks = options.blocks;\r\n\r\n    let b;\r\n    let end; // for while loop in replacing\r\n    \r\n    let repBlock = (match, content) => {\r\n      let name = getRandomName();\r\n      let args = [];\r\n      if (b.parser) {\r\n        if(b.parser === 'inherit'){\r\n          args = [this.__parse(content, options, operations)];\r\n        }else{\r\n          args = [b.parser(content)];\r\n        }\r\n      }\r\n      let sn = new Node(\"block\", args, {\r\n        name: b.name,\r\n        match: options.getMatchedString(match, operations),\r\n        content: options.getMatchedString(content, operations)\r\n      });\r\n      operations.set(name, sn);\r\n      end = false;\r\n      return name;\r\n    };\r\n\r\n    for (let i = 0; i < blocks.values.length; i++) {\r\n      b = blocks.values[i];\r\n      end = false;\r\n      while (!end) {\r\n        end = true;\r\n        str = str.replace(b.regex, repBlock);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n  __parseOperators(str, options, operations) {\r\n    /// RegExp: (arg)(suffix)(op)(prefix)(arg)\r\n    /// ((?:[a-zA-Z_]+\\d*)|(?:-?\\d+\\.?\\d*)|(?:-?\\d*\\.?\\d+))\\s*((?:\\+\\+))?\\s*((?:\\+))\\s*((?:\\+\\+|\\+|\\-))?\\s*((?:[a-zA-Z_]+\\d*)|(?:\\d+\\.?\\d*)|(?:\\d*\\.?\\d+))\r\n\r\n    //#region separators\r\n    for (let s of options.separators) {\r\n      if (contains(str, s.id)) {\r\n        let name = getRandomName();\r\n        let args = [];\r\n        let strs = str.split(s);\r\n        for (let str_ of strs) {\r\n          args.push(this.__parse(str_, options, operations));\r\n        }\r\n        operations.set(\r\n          name,\r\n          new Node(\"separator\", args, {\r\n            name: s.name,\r\n            length: args.length, \r\n            match: options.getMatchedString(str, operations)\r\n          })\r\n         );\r\n         return name;\r\n      }\r\n    }\r\n    //#endregion\r\n\r\n    //#region preparing for parsing process\r\n    let _str = \"\",\r\n      prevArg = null;\r\n    //#endregion\r\n\r\n    //#region searching for operators and parsing suffix and prefix\r\n    /// intial replacement\r\n    str = str.replace(options.opIntialTestReg, (match, prefix, arg) => {\r\n      if (prefix) {\r\n        let name = getRandomName();\r\n        let sn = new Node(\"prefixOperator\", this.__parseArg(arg, options, operations), {\r\n          name: prefix,\r\n          match: options.getMatchedString(match, operations),\r\n        });\r\n        operations.set(name, sn);\r\n        prevArg = name;\r\n      } else {\r\n        prevArg = arg;\r\n      }\r\n      return \"\";\r\n    });\r\n\r\n    let end = false;\r\n    // inner search for operators\r\n    while (!end) {\r\n      end = true;\r\n      /// if replacement is not implemented, str will sstill the same and while loop will close\r\n      str = str.replace(options.opTestReg, (match, suffix, op, prefix, arg) => {\r\n        if (!op) {\r\n          sendError(\"operators\", \"invalid operators\", str, null);\r\n        }\r\n\r\n        if (suffix) {\r\n          /// creating an operations with type of suffix operator,,, its arg is the prev arg\r\n          let name = getRandomName();\r\n          let sn = new Node(\"suffixOperator\", this.__parseArg(prevArg, options, operations), {\r\n            name: suffix,\r\n            match: options.getMatchedString(prevArg + suffix, operations)\r\n          });\r\n          operations.set(name, sn);\r\n          prevArg = name;\r\n        }\r\n\r\n        _str += `${prevArg} ${op} `;\r\n\r\n        if (prefix) {\r\n          /// creating an operations with type of prefix operator,,, its arg is the prev arg\r\n          let name = getRandomName();\r\n          let sn = new Node(\"prefixOperator\", this.__parseArg(arg, options, operations), {\r\n            name: prefix,\r\n            match: options.getMatchedString( prefix + arg, operations)\r\n          });\r\n          operations.set(name, sn);\r\n          prevArg = name;\r\n        } else {\r\n          prevArg = arg;\r\n        }\r\n\r\n        end = false;\r\n        return \"\";\r\n      });\r\n    }\r\n\r\n    // final search\r\n    if (str !== \"\") {\r\n      str = str.replace(options.opFinalTestReg, (match, suffix) => {\r\n        let name = getRandomName();\r\n        let sn = new Node(\"suffixOperator\", this.__parseArg(prevArg, options, operations), {\r\n          name: suffix,\r\n          match: options.getMatchedString(prevArg + match, operations)\r\n        });\r\n        operations.set(name, sn);\r\n        _str += name;\r\n        return \"\";\r\n      });\r\n      if (str !== \"\")\r\n        sendError(\"operators\", \"invalid suffix operator at the end\", \"\", null);\r\n    } else {\r\n      _str += prevArg;\r\n    }\r\n    //#endregion\r\n    \r\n    end = options.argTestReg.test(_str);\r\n\r\n    //#region parsing operators\r\n    if (!end) {\r\n      for (let i = 0; i < options.operators.length; i++) {\r\n        end = false;\r\n        while (!end) {\r\n          end = true;\r\n          if (contains(_str, options.operators[i].id)) {\r\n            _str = _str.replace(\r\n              new RegExp(\r\n                `(${options.argTest}) (${options.operators[i].regexStr}) (${options.argTest})`\r\n              ),\r\n              (match, g1, op, g2) => {\r\n                let arg1 = this.__parseArg(g1, options, operations),\r\n                  arg2 = this.__parseArg(g2, options, operations);\r\n                let name = getRandomName();\r\n                operations.set(\r\n                  name,\r\n                  new Node(\"operator\", [arg1, arg2], {\r\n                    name: op,\r\n                    match: options.getMatchedString(match, operations)\r\n                  })\r\n                );\r\n                end = false;\r\n                return name;\r\n              }\r\n            );\r\n          }\r\n          /// if the operator is not found,,, end the while loop.\r\n        }\r\n      }\r\n    }\r\n    //#endregion\r\n\r\n    return _str;\r\n  }\r\n\r\n  __parseArg(str, options, operations) {\r\n    //#region the last thing in str,,, number or name or operationName\r\n    let snode;\r\n\r\n    // if name of operation\r\n    str = str.replace(/^\\s*(.*)\\s*$/, \"$1\");\r\n\r\n    /// if number\r\n    if (!isNaN(str)) {\r\n      snode = new Node(\"number\", [], {\r\n        value: parseFloat(str),\r\n        match: str,\r\n      });\r\n    }\r\n    if (snode) return snode;\r\n\r\n    // if operation name\r\n    str = str.replace(\r\n      options.operationTestGroupedReg,\r\n      (match, funcName, opName) => {\r\n        snode = operations.get(opName);\r\n        if (funcName && snode.type === 'block' && snode.name === '()') {\r\n          if (options.vars.find(v => v === funcName)) {\r\n            //\r\n          }\r\n          snode = new Node(\"functionCalling\", snode.args, {\r\n            name: funcName,\r\n            match: options.getMatchedString(match, operations)\r\n          });\r\n        }else if(funcName){\r\n          throw new Error('you have inputted a name (identifier) then an invalid block after it.');\r\n        }\r\n      }\r\n    );\r\n    if (snode) return snode;\r\n\r\n    // if literal (variable) or bool {true or false}, ...\r\n    str = str.replace(options.nameTestReg, name => {\r\n      snode = new Node(\"variable\", [], { name, match: str});\r\n    });\r\n    if (snode) return snode;\r\n\r\n    //#endregion\r\n\r\n    // this shouldn't happen in ordinary cases, but this line of code is here for avoiding any flaw out of measurements\r\n    throw new Error(\"invalid script.\\n\" + str);\r\n  }\r\n}\r\n","import { Operator, Separator, PrefixOperator, SuffixOperator } from '../tokens/Operators.js';\r\nimport block from '../tokens/Block.js';\r\nimport Node from '../Node.js';\r\nimport { sendError, contains, getRandomName } from '../global.js';\r\n\r\nexport default class ProgMathParser {\r\n\r\n   constructor(options) {\r\n      this._options = {\r\n         autoMultSign: true,\r\n         vars: [], /// to be used in this case ::: ' 1 + var(2-5)' which is the same as ' 1+ var*(2-5)'\r\n         nameTest: '[a-zA-Z_]+\\\\d*',\r\n         numTest: '\\\\d+\\\\.?\\\\d*|\\\\d*\\\\.?\\\\d+',\r\n\r\n         prefixOperators: [\r\n            new PrefixOperator({ id: '+' }),\r\n            new PrefixOperator({ id: '-' }),\r\n         ],\r\n\r\n         suffixOperators: [\r\n            new SuffixOperator({ id: '!' }),\r\n            new SuffixOperator({ id: 'deg' }),\r\n            new SuffixOperator({ id: 'rad' }),\r\n         ],\r\n\r\n         operators: [\r\n\r\n            new Operator({ id: '^', zIndex: 10 }), // the first operator to process\r\n            new Operator({ id: '*', zIndex: 9 }),\r\n            new Operator({ id: '/', zIndex: 9 }),\r\n            new Operator({ id: 'mod', zIndex: 9 }),\r\n            new Operator({ id: '+', zIndex: 7 }),\r\n            new Operator({ id: '-', zIndex: 7 }),\r\n            new Operator({ id: '>>', zIndex: 6 }),\r\n            new Operator({ id: '<<', zIndex: 6 }),\r\n            new Operator({ id: '>=', zIndex: 5 }),\r\n            new Operator({ id: '<=', zIndex: 5 }),\r\n            new Operator({ id: '!=', zIndex: 5 }),\r\n            new Operator({ id: '<', zIndex: 5 }),\r\n            new Operator({ id: '>', zIndex: 5 }),\r\n            new Operator({ id: '==', zIndex: 5 }),\r\n            new Operator({ id: '&', zIndex: 4 }),\r\n            new Operator({ id: 'band', zIndex: 4 }),\r\n            new Operator({ id: '|', zIndex: 4 }),\r\n            new Operator({ id: 'bor', zIndex: 4 }),\r\n            new Operator({ id: 'bxor', zIndex: 4 }),\r\n            new Operator({ id: 'constrain', zIndex: 4 }),\r\n            new Operator({ id: 'in', zIndex: 3 }),\r\n            new Operator({ id: 'out', zIndex: 3 }),\r\n            new Operator({ id: 'xnor', zIndex: 1 }),\r\n            new Operator({ id: 'xor', zIndex: 1 }),\r\n            new Operator({ id: 'nand', zIndex: 1 }),\r\n            new Operator({ id: 'nor', zIndex: 1 }),\r\n            new Operator({ id: 'or', zIndex: 1 }),\r\n            new Operator({ id: 'and', zIndex: 1 }),\r\n            new Operator({ id: '||', zIndex: 1 }),\r\n            new Operator({ id: '&&', zIndex: 1 }),\r\n            new Operator({ id: '=', zIndex: 0 }) // the last operator to be applied\r\n\r\n         ],\r\n\r\n         separators: [\r\n            new Separator({ id: ';' }),\r\n            new Separator({ id: ',' }),\r\n         ],\r\n\r\n         blocks: [\r\n            new block({ id: { opening: '{', closing: '}' } }), /// multiNodable used to know whether or not the bracket block can have multiNode seperated be something like comma \",\"\r\n            new block({ id: { opening: '[', closing: ']' } }),\r\n            new block({ id: { opening: '(', closing: ')' } }),\r\n            new block({ id: { opening: '\"', closing: '\"' } }),\r\n            new block({ id: { opening: \"'\", closing: \"'\" } })\r\n         ],\r\n\r\n         forbiddenChars: [],\r\n\r\n      };\r\n      this.options = options;\r\n   }\r\n\r\n   get options() {\r\n      return this._options;\r\n   }\r\n\r\n   set options(options) {\r\n      options = Object.assign(this._options, options);\r\n      prepareOptions(options);\r\n   }\r\n\r\n   parse(str, operations = null) {\r\n      var options = this.options;\r\n      operations = operations instanceof Map ? operations : new Map();\r\n      //#region pre codes\r\n      for (let i = 0; i < options.forbiddenChars.length; i++) {\r\n         if (contains(str, options.forbiddenChars[i])) sendError('forbiddenSymbol', 'forbidden symbol.');\r\n      }\r\n      // if empty\r\n      str = str.replace(/\\s+/g, () => {\r\n         return ' ';\r\n      });\r\n\r\n      //#endregion\r\n      return this.__parse(str, options, operations);\r\n   }\r\n\r\n   __parse(str, options, operations, subOptions = {}) {\r\n\r\n      let snode;\r\n      subOptions = Object.assign({ parseBlocks: true, parseOperators: true }, subOptions); /// or use Object.assign\r\n\r\n      //#region parsing\r\n\r\n      // if empty of characters\r\n      str = str.replace(/^\\s*$/, () => {\r\n         snode = new Node('');\r\n      }); if (snode) return snode;\r\n\r\n      if (subOptions.parseBlocks) {\r\n         str = this.__parseBlocks(str, options, operations);\r\n      }\r\n      if (subOptions.parseOperators) {\r\n         str = this.__parseOperators(str, options, operations);\r\n      }\r\n\r\n      //#endregion\r\n\r\n      //#region the last thing in str,,, number or name or operationName \r\n\r\n      // if name of operation\r\n      str = str.replace(/^\\s*(.*)\\s*$/, '$1');\r\n\r\n      /// if number\r\n      if (!isNaN(str)) {\r\n         snode = new Node('number', [], { value: parseFloat(str) });\r\n      }\r\n\r\n      // if operation name\r\n      str = str.replace(options.operationTestReg, (opName) => {\r\n         snode = operations.get(opName);\r\n      }); if (snode) return snode;\r\n\r\n      // if literal (variable) or bool {true or false}, ...\r\n      str = str.replace(options.nameTestReg, (name) => {\r\n         snode = new Node('variable', [], { name });\r\n      }); if (snode) return snode;\r\n\r\n      //#endregion\r\n\r\n      // this shouldn't happen in ordinary cases, but this line of code is here for avoiding any flaw out of measurements\r\n      throw new Error('invalid script.\\n' + str);\r\n\r\n   }\r\n\r\n   /**\r\n    * this modified version of __parseBlocks is much better and faster,,, we have gotten rid of if statements and varaible and alot of code that are redundant\r\n    */\r\n   __parseBlocks(str, options, operations) {\r\n\r\n      //#region brackets\r\n\r\n      var blocks = options.blocks;\r\n\r\n      let b;\r\n      let repBlock = (match, content) => {\r\n         let name = getRandomName();\r\n         let sn = new Node('block', [this.__parse(content, options, operations)], { id: b.id });\r\n         operations.set(name, sn);\r\n         return name;\r\n      };\r\n\r\n      for (let i = 0; i < blocks.values.length; i++) {\r\n         b = blocks.values[i];\r\n         str = str.replace(b.regex, repBlock);\r\n      }\r\n\r\n      //#endregion\r\n\r\n      return str;\r\n   }\r\n\r\n   __parseOperators(str, options, operations) {\r\n      /// RegExp: (var or num or block)(suffix)(op)(prefix)(var or num or block)\r\n      /// ((?:[a-zA-Z_]+\\d*)|(?:-?\\d+\\.?\\d*)|(?:-?\\d*\\.?\\d+))\\s*((?:\\+\\+))?\\s*((?:\\+))\\s*((?:\\+\\+|\\+|\\-))?\\s*((?:[a-zA-Z_]+\\d*)|(?:\\d+\\.?\\d*)|(?:\\d*\\.?\\d+))\r\n\r\n      //#region separators\r\n      for (let s of options.separators) {\r\n         if (contains(str, s.id)) {\r\n            let name = this.__get;\r\n            let args = [];\r\n            let strs = str.split(s);\r\n            for (let str_ of strs) {\r\n               args.push(this.__parse(str_, options, operations));\r\n            }\r\n            operations.set(name, new Node('separator', args, { name: s.id, length: args.length }));\r\n         }\r\n      }\r\n      //#endregion\r\n\r\n      //#region preparing for parsing process\r\n      let _str = '',\r\n         prevArg = {\r\n            name: null,\r\n            sn: null\r\n         };\r\n      //#endregion\r\n\r\n      //#region searching for operators and parsing suffix and prefix\r\n\r\n      /// intial replacement\r\n      str = str.replace(options.opIntialTestReg, (match, prefix, arg) => {\r\n         if (prefix) {\r\n            let a = arg,\r\n               b = 'prefixOperator',\r\n               c = prefix;\r\n            if (!isNaN(a)) {\r\n               /// number\r\n               let name = getRandomName();\r\n               let sn = new Node(\r\n                  b,\r\n                  new Node('number', [], { value: parseInt(a) }),\r\n                  { name: c }\r\n               );\r\n               operations.set(name, sn);\r\n               prevArg = { name, sn };\r\n            } else {\r\n               let found = false;\r\n               a.replace(options.operationTestReg, () => {\r\n                  found = true;\r\n               });\r\n               if (found) {\r\n                  /// operations\r\n                  let sn = new Node(\r\n                     b,\r\n                     operations.get(a), /// you can get it from operations but let's store it into prevArg.sn to speed our code a litte bit.\r\n                     { name: c }\r\n                  );\r\n                  operations.set(a, sn);\r\n                  prevArg.sn = { name: a, sn };\r\n               } else {\r\n                  /// varName\r\n                  let name = getRandomName();\r\n                  let sn = new Node(\r\n                     b,\r\n                     new Node('variable', [], { name: a }),\r\n                     { name: c }\r\n                  );\r\n                  operations.set(name, sn);\r\n                  prevArg = { name, sn };\r\n               }\r\n            }\r\n\r\n         } else {\r\n            let found = false;\r\n            arg.replace(options.operationTestReg, () => {\r\n               found = true;\r\n            });\r\n            if (found) {\r\n               prevArg = { name: arg, sn: operations.get(arg) };\r\n            } else {\r\n               prevArg = { name: arg };\r\n            }\r\n         }\r\n\r\n         return '';\r\n      });\r\n\r\n      let end = false;\r\n      // inner search for operators\r\n      while (!end) {\r\n         end = true;\r\n         /// if replacement is not implemented, str will sstill the same and while loop will close\r\n         str = str.replace(options.opTestReg, (match, suffix, op, prefix, arg) => {\r\n\r\n            if (!op) {\r\n               sendError('operators', 'invalid operators', str, null);\r\n            }\r\n\r\n            if (suffix) {\r\n               /// creating an operations with type of  prefix operator,,, its arg is the prev arg\r\n               let a = prevArg,\r\n                  b = 'suffixOperator',\r\n                  c = suffix;\r\n               if (!isNaN(a)) {\r\n                  /// number\r\n                  let name = getRandomName();\r\n                  let sn = new Node(\r\n                     b,\r\n                     new Node('number', [], { value: parseInt(a) }),\r\n                     { name: c }\r\n                  );\r\n                  operations.set(name, sn);\r\n                  prevArg = { name, sn };\r\n               } else {\r\n                  let found = false;\r\n                  a.replace(options.operationTestReg, () => {\r\n                     found = true;\r\n                  });\r\n                  if (found) {\r\n                     /// operations\r\n                     let sn = new Node(\r\n                        b,\r\n                        prevArg.sn, /// you can get it from operations but let's store it into prevArg.sn to speed our code a litte bit.\r\n                        { name: c }\r\n                     );\r\n                     operations.set(a, sn);\r\n                     prevArg.sn = sn;\r\n                  } else {\r\n                     /// varName\r\n                     let name = getRandomName();\r\n                     let sn = new Node(\r\n                        b,\r\n                        new Node('variable', [], { name: a }),\r\n                        { name: c }\r\n                     );\r\n                     operations.set(name, sn);\r\n                     prevArg = { name, sn };\r\n                  }\r\n               }\r\n            }\r\n\r\n            _str += `${prevArg.name} ${op} `;\r\n\r\n            if (prefix) {\r\n               let a = arg,\r\n                  b = 'prefixOperator',\r\n                  c = prefix;\r\n               if (!isNaN(a)) {\r\n                  /// number\r\n                  let name = getRandomName();\r\n                  let sn = new Node(\r\n                     b,\r\n                     new Node('number', [], { value: parseInt(a) }),\r\n                     { name: c }\r\n                  );\r\n                  operations.set(name, sn);\r\n                  prevArg = { name, sn };\r\n               } else {\r\n                  let found = false;\r\n                  a.replace(options.operationTestReg, () => {\r\n                     found = true;\r\n                  });\r\n                  if (found) {\r\n                     /// operations\r\n                     let sn = new Node(\r\n                        b,\r\n                        operations.get(a), /// you can get it from operations but let's store it into prevArg.sn to speed our code a litte bit.\r\n                        { name: c }\r\n                     );\r\n                     operations.set(a, sn);\r\n                     prevArg.sn = { name: a, sn };\r\n                  } else {\r\n                     /// varName\r\n                     let name = getRandomName();\r\n                     let sn = new Node(\r\n                        b,\r\n                        new Node('variable', [], { name: a }),\r\n                        { name: c }\r\n                     );\r\n                     operations.set(name, sn);\r\n                     prevArg = { name, sn };\r\n                  }\r\n               }\r\n            } else {\r\n               let found = false;\r\n               arg.replace(options.operationTestReg, () => {\r\n                  found = true;\r\n               });\r\n               if (found) {\r\n                  prevArg = { name: arg, sn: operations.get(arg) };\r\n               } else {\r\n                  prevArg = { name: arg };\r\n               }\r\n            }\r\n\r\n            end = false;\r\n            return '';\r\n         });\r\n      }\r\n\r\n      // final search\r\n      if (str !== '') {\r\n         str = str.replace(options.opFinalTestReg, (match, suffix) => {\r\n\r\n            let a = prevArg.name,\r\n               b = 'suffixOperator',\r\n               c = suffix;\r\n            if (!isNaN(a)) {\r\n               /// number\r\n               let name = getRandomName();\r\n               let sn = new Node(\r\n                  b,\r\n                  new Node('number', [], { value: parseInt(a) }),\r\n                  { name: c }\r\n               );\r\n               operations.set(name, sn);\r\n               prevArg = { name, sn };\r\n            } else {\r\n               let found = false;\r\n               a.replace(options.operationTestReg, () => {\r\n                  found = true;\r\n               });\r\n               if (found) {\r\n                  /// operations\r\n                  let sn = new Node(\r\n                     b,\r\n                     prevArg.sn, /// you can get it from operations but let's store it into prevArg.sn to speed our code a litte bit.\r\n                     { name: c }\r\n                  );\r\n                  operations.set(a, sn);\r\n                  prevArg.sn = { name: a, sn };\r\n               } else {\r\n                  /// varName\r\n                  let name = getRandomName();\r\n                  let sn = new Node(\r\n                     b,\r\n                     new Node('variable', [], { name: a }),\r\n                     { name: c }\r\n                  );\r\n                  operations.set(name, sn);\r\n                  prevArg = { name, sn };\r\n               }\r\n            }\r\n\r\n            _str += prevArg.name;\r\n\r\n            return '';\r\n\r\n         });\r\n         if (str !== '') sendError('operators', 'invalid suffix operator at the end', '', null);\r\n      } else {\r\n         _str += prevArg.name;\r\n      }\r\n\r\n      //#endregion\r\n\r\n      //#region parsing operators\r\n\r\n      for (let i = 0; i < options.operators.length; i++) {\r\n         end = false;\r\n         while (!end) {\r\n            end = true;\r\n            if (contains(_str, options.operators[i].id)) {\r\n               _str = _str.replace(new RegExp(`(${options.argTest})\\\\s*(${options.operators[i].regexStr})\\\\s*(${options.argTest})`), (match, g1, op, g2) => {\r\n                  //#region argument for the operator\r\n                  let arg1, arg2;\r\n                  if (!isNaN(g1)) {\r\n                     /// number\r\n                     arg1 = new Node('number', [], { value: parseInt(g1) });\r\n                  } else {\r\n                     let found = false;\r\n                     g1.replace(options.operationTestReg, () => {\r\n                        // operation\r\n                        arg1 = operations.get(g1);\r\n                        found = true;\r\n                     });\r\n                     if (!found) {\r\n                        /// varName\r\n                        arg1 = new Node('variable', [], { name: g1 });\r\n                     }\r\n                  }\r\n                  if (!isNaN(g2)) {\r\n                     /// number\r\n                     arg2 = new Node('number', [], { value: parseInt(g2) });\r\n                  } else {\r\n                     let found = false;\r\n                     g2.replace(options.operationTestReg, () => {\r\n                        // operation\r\n                        arg2 = operations.get(g2);\r\n                        found = true;\r\n                     });\r\n                     if (!found) {\r\n                        /// varName\r\n                        arg2 = new Node('variable', [], { name: g2 });\r\n                     }\r\n                  }\r\n                  //#endregion\r\n                  let name = getRandomName();\r\n                  operations.set(name, new Node('operator', [arg1, arg2], { name: op }));\r\n                  end = false;\r\n                  return name;\r\n               });\r\n            }\r\n            /// if the operator is not found,,, end the while loop.\r\n         }\r\n      }\r\n\r\n      //#endregion\r\n\r\n      return _str;\r\n   }\r\n\r\n}","\r\nimport Block from './Block.js';\r\nimport { Operator, SuffixOperator, PrefixOperator, Separator } from './Operators.js';\r\n\r\nexport default {\r\n   Operator, SuffixOperator, PrefixOperator, Separator,\r\n   Block\r\n};","import Rule from './Rule.js';\r\nimport Node from '../Node.js';\r\n\r\nexport default class AnyOf extends Rule {\r\n   constructor(childrenRules, properties) {\r\n      if (childrenRules.length == 0) throw new Error('Sequence musn\\t be void.');\r\n      super('AnyOf', -1, childrenRules, properties);\r\n   }\r\n\r\n   getRegex(groubIndex) {\r\n      groubIndex = groubIndex || {\r\n         num: 0,\r\n         increase: function (step = 1) {\r\n            this.num += step;\r\n            return this;\r\n         }\r\n      };\r\n      this.index = groubIndex.num;\r\n\r\n      //#region getting regex\r\n      let regex = '';\r\n      this.childrenRules.forEach(child => {\r\n         regex += child.getRegex(groubIndex.increase()) + '|';\r\n      });\r\n      //#endregion\r\n\r\n      return `(${regex})`;\r\n   }\r\n\r\n   parse(groups, useValue) {\r\n\r\n      let value = useValue || groups[this.index + 1];\r\n      let args = [];\r\n\r\n      if (this.blockState) {\r\n         value = value.replace(this.rootParser.matchesTest, (match, id, index) => {\r\n            return this.rootParser.matches[id][index].str;\r\n         });\r\n      }\r\n\r\n      //#region getting args\r\n      for (let child of this.childrenRules) {\r\n         if (groups.values[child.index]) {\r\n            // this is the child being found\r\n            args.push(child.parse(groups));\r\n            break;\r\n         }\r\n      }\r\n      //#endregion\r\n\r\n      return new Node(this.name, args, {\r\n         match: value\r\n      });\r\n\r\n   }\r\n\r\n}","import Rule from './Rule.js';\r\nimport Node from '../Node.js';\r\n\r\nexport default class AnyThing extends Rule {\r\n   constructor(properties) {\r\n      super('Anything', 0, [], properties);\r\n   }\r\n\r\n   getRegex(groubIndex = 0) {\r\n      groubIndex = groubIndex || {\r\n         num: 0,\r\n         increase: function (step = 1) {\r\n            this.num += step;\r\n            return this;\r\n         }\r\n      };\r\n      this.index = groubIndex.num;\r\n      return `(.*?)`;\r\n   }\r\n\r\n   parse(groups, useValue) {\r\n\r\n      let value = useValue || groups[this.index + 1];\r\n      let args = [];\r\n\r\n      if (this.blockState) {\r\n         value = value.replace(this.rootParser.matchesTest, (match, id, index) => {\r\n            return this.rootParser.matches[id][index].str;\r\n         });\r\n      }\r\n\r\n      //#region getting args\r\n      if (this.parser) {\r\n         args.push(this.parser.parse(value));\r\n      }\r\n      //#endregion\r\n\r\n      return new Node(this.name, args, { match: value });\r\n\r\n   }\r\n\r\n}","import Rule from './Rule.js';\r\nimport Node from '../Node.js';\r\n\r\nexport default class Repeat extends Rule {\r\n   constructor(childRule, properties) {\r\n      properties = Object.assign({ spaced: true }, properties);\r\n      super('Repeat', 1, [childRule], properties);\r\n   }\r\n\r\n   getRegex(groubIndex) {\r\n      groubIndex = groubIndex || {\r\n         num: 0,\r\n         increase: function (step = 1) {\r\n            this.num += step;\r\n            return this;\r\n         }\r\n      };\r\n      this.index = groubIndex.num;\r\n\r\n      let timesTOrepeat = !isNaN(this.length) ? `{${this.length}}` : `+`;\r\n\r\n      let content = this.childrenRules[0].getRegex(groubIndex.increase());\r\n      this.repeatedRegex = new RegExp(content, 'g');\r\n\r\n      let regex;\r\n      if (this.spaced) {\r\n         regex = `(?:${content}\\\\s*)${timesTOrepeat}`;\r\n      } else {\r\n         regex = `${content}${timesTOrepeat}`;\r\n      }\r\n\r\n      this.regex = regex;\r\n      return `(${regex})`;\r\n   }\r\n\r\n   parse(groups, useValue) {\r\n\r\n      let value = useValue || groups[this.index + 1];\r\n      let args = [];\r\n\r\n      //#region getting args\r\n      value.replace(this.repeatedRegex, (match) => {\r\n         args.push(this.childrenRules[0].parse(groups, match));\r\n         return '';\r\n      });\r\n      //#endregion\r\n\r\n      if (this.blockState) {\r\n         value = value.replace(this.rootParser.matchesTest, (match, id, index) => {\r\n            return this.rootParser.matches[id][index].str;\r\n         });\r\n      }\r\n\r\n      return new Node(this.name, args, {\r\n         match: value,\r\n      });\r\n\r\n   }\r\n\r\n}","import Rule from './Rule.js';\r\nimport Node from '../Node.js';\r\nexport default class Sequence extends Rule {\r\n   constructor(childrenRules, properties) {\r\n      properties = Object.assign({ spaced: true }, properties);\r\n      if (childrenRules.length == 0) throw new Error('Sequence musn\\t be void.');\r\n      super('Sequence', -1, childrenRules, properties);\r\n   }\r\n\r\n   getRegex(groubIndex) {\r\n      groubIndex = groubIndex || {\r\n         num: 0,\r\n         increase: function (step = 1) {\r\n            this.num += step;\r\n            return this;\r\n         }\r\n      };\r\n      this.index = groubIndex.num;\r\n\r\n      //#region getting regex\r\n      let regex = '';\r\n      this.childrenRules.forEach(child => {\r\n         regex += child.getRegex(groubIndex.increase());\r\n         if (this.spaced) {\r\n            regex += `\\\\s*`;\r\n         }\r\n      });\r\n      if (this.spaced) {\r\n         regex = regex.slice(0, -('\\\\s*'.length)); /// remove the last \\s* in the string\r\n      }\r\n      //#endregion\r\n\r\n      this.regex = regex;\r\n      return `(${regex})`;\r\n   }\r\n\r\n   parse(groups, useValue) {\r\n\r\n      let value = useValue || groups[this.index + 1];\r\n      let args = [];\r\n\r\n      //#region getting args\r\n      for (let child of this.childrenRules) {\r\n         args.push(child.parse(groups));\r\n      }\r\n      //#endregion\r\n\r\n      if (this.blockState) {\r\n         value = value.replace(this.rootParser.matchesTest, (match, id, index) => {\r\n            return this.rootParser.matches[id][index].str;\r\n         });\r\n      }\r\n\r\n      return new Node(this.name, args, {\r\n         match: value,\r\n      });\r\n\r\n   }\r\n\r\n\r\n}","import Parser from './Parser.js';\r\nimport OperatorsParser from './OperatorsParser.js';\r\nimport CustomParsers from './customParsers/index.js';\r\nimport TOKENS from './tokens/TOKENS.js';\r\nimport Tokens from './tokens/index.js';\r\nimport Rules from './rules/index.js';\r\nimport Node from './Node.js';\r\n\r\nvar MagicalParser = { Node, Parser, OperatorsParser, CustomParsers, TOKENS, Tokens, Rules };\r\n\r\nexport default MagicalParser;\r\n","/***\r\n * Ready To Use Regex For Rules\r\n */\r\nexport default {\r\n   STRING: `\"(?:[^\"]|\\\\\")*\"`,\r\n   NUMBER: `\\\\d+\\.\\\\d*|\\\\d*\\.\\\\d+`,\r\n   BRACKETS: `\\\\{.*?\\\\}`,\r\n   ROUND_BRACKETS: `\\\\(.*?\\\\)`,\r\n   CURLEY_BRACKETS: `\\\\{.*?\\\\}`,\r\n   SQUARE_BRACKETS: `\\\\[.*?\\\\]`,\r\n}\r\n\r\n\r\n","import AnyOf from './AnyOf.js';\r\nimport AnyThing from './AnyThing.js';\r\nimport Block from './Block.js';\r\nimport Repeat from './Repeat.js';\r\nimport Sequence from './Sequence.js';\r\nimport Rule from './Rule.js';\r\n\r\nexport default {\r\n   AnyOf, AnyThing, Block, Repeat, Sequence, Rule\r\n};"],"sourceRoot":""}